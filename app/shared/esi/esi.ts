// tslint:disable
// eslint-disable
import * as request from "superagent";
import {
    SuperAgentStatic,
    SuperAgentRequest,
    Response
} from "superagent";

export type RequestHeaders = {
    [header: string]: string;
}
export type RequestHeadersHandler = (headers: RequestHeaders) => RequestHeaders;

export type ConfigureAgentHandler = (agent: SuperAgentStatic) => SuperAgentStatic;

export type ConfigureRequestHandler = (agent: SuperAgentRequest) => SuperAgentRequest;

export type CallbackHandler = (err: any, res ? : request.Response) => void;

export type bad_request = {
    'error': string;
} & {
    [key: string]: any;
};

export type error_limited = {
    'error': string;
} & {
    [key: string]: any;
};

export type forbidden = {
    'error': string;
    'sso_status' ? : number;
} & {
    [key: string]: any;
};

export type gateway_timeout = {
    'error': string;
    'timeout' ? : number;
} & {
    [key: string]: any;
};

export type internal_server_error = {
    'error': string;
} & {
    [key: string]: any;
};

export type service_unavailable = {
    'error': string;
} & {
    [key: string]: any;
};

export type unauthorized = {
    'error': string;
} & {
    [key: string]: any;
};

export type Response_get_alliances_200 = Array < number >
;

export type Response_get_alliances_alliance_id_200 = {
    'creator_corporation_id': number;
    'creator_id': number;
    'date_founded': string;
    'executor_corporation_id' ? : number;
    'faction_id' ? : number;
    'name': string;
    'ticker': string;
} & {
    [key: string]: any;
};

export type Response_get_alliances_alliance_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_alliances_alliance_id_contacts_200 = Array < {
        'contact_id': number;
        'contact_type': "character" | "corporation" | "alliance" | "faction";
        'label_ids' ? : Array < number >
        ;
        'standing': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_alliances_alliance_id_contacts_labels_200 = Array < {
        'label_id': number;
        'label_name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_alliances_alliance_id_corporations_200 = Array < number >
;

export type Response_get_alliances_alliance_id_icons_200 = {
    'px128x128' ? : string;
    'px64x64' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_alliances_alliance_id_icons_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_characters_affiliation_200 = Array < {
        'alliance_id' ? : number;
        'character_id': number;
        'corporation_id': number;
        'faction_id' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_characters_affiliation_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_200 = {
    'alliance_id' ? : number;
    'ancestry_id' ? : number;
    'birthday': string;
    'bloodline_id': number;
    'corporation_id': number;
    'description' ? : string;
    'faction_id' ? : number;
    'gender': "female" | "male";
    'name': string;
    'race_id': number;
    'security_status' ? : number;
    'title' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_agents_research_200 = Array < {
        'agent_id': number;
        'points_per_day': number;
        'remainder_points': number;
        'skill_type_id': number;
        'started_at': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_assets_200 = Array < {
        'is_blueprint_copy' ? : boolean;
        'is_singleton': boolean;
        'item_id': number;
        'location_flag': "AssetSafety" | "AutoFit" | "BoosterBay" | "Cargo" | "CorpseBay" | "Deliveries" | "DroneBay" | "FighterBay" | "FighterTube0" | "FighterTube1" | "FighterTube2" | "FighterTube3" | "FighterTube4" | "FleetHangar" | "Hangar" | "HangarAll" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "HiddenModifiers" | "Implant" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "Locked" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "QuafeBay" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "RigSlot3" | "RigSlot4" | "RigSlot5" | "RigSlot6" | "RigSlot7" | "ShipHangar" | "Skill" | "SpecializedAmmoHold" | "SpecializedCommandCenterHold" | "SpecializedFuelBay" | "SpecializedGasHold" | "SpecializedIndustrialShipHold" | "SpecializedLargeShipHold" | "SpecializedMaterialBay" | "SpecializedMediumShipHold" | "SpecializedMineralHold" | "SpecializedOreHold" | "SpecializedPlanetaryCommoditiesHold" | "SpecializedSalvageHold" | "SpecializedShipHold" | "SpecializedSmallShipHold" | "SubSystemBay" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3" | "SubSystemSlot4" | "SubSystemSlot5" | "SubSystemSlot6" | "SubSystemSlot7" | "Unlocked" | "Wardrobe";
        'location_id': number;
        'location_type': "station" | "solar_system" | "item" | "other";
        'quantity': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_characters_character_id_assets_locations_200 = Array < {
        'item_id': number;
        'position': {
            'x': number;
            'y': number;
            'z': number;
        } & {
            [key: string]: any;
        };
    } & {
        [key: string]: any;
    } >
;

export type Response_post_characters_character_id_assets_names_200 = Array < {
        'item_id': number;
        'name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_attributes_200 = {
    'accrued_remap_cooldown_date' ? : string;
    'bonus_remaps' ? : number;
    'charisma': number;
    'intelligence': number;
    'last_remap_date' ? : string;
    'memory': number;
    'perception': number;
    'willpower': number;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_blueprints_200 = Array < {
        'item_id': number;
        'location_flag': "AutoFit" | "Cargo" | "CorpseBay" | "DroneBay" | "FleetHangar" | "Deliveries" | "HiddenModifiers" | "Hangar" | "HangarAll" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "AssetSafety" | "Locked" | "Unlocked" | "Implant" | "QuafeBay" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "RigSlot3" | "RigSlot4" | "RigSlot5" | "RigSlot6" | "RigSlot7" | "ShipHangar" | "SpecializedFuelBay" | "SpecializedOreHold" | "SpecializedGasHold" | "SpecializedMineralHold" | "SpecializedSalvageHold" | "SpecializedShipHold" | "SpecializedSmallShipHold" | "SpecializedMediumShipHold" | "SpecializedLargeShipHold" | "SpecializedIndustrialShipHold" | "SpecializedAmmoHold" | "SpecializedCommandCenterHold" | "SpecializedPlanetaryCommoditiesHold" | "SpecializedMaterialBay" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3" | "SubSystemSlot4" | "SubSystemSlot5" | "SubSystemSlot6" | "SubSystemSlot7" | "FighterBay" | "FighterTube0" | "FighterTube1" | "FighterTube2" | "FighterTube3" | "FighterTube4" | "Module";
        'location_id': number;
        'material_efficiency': number;
        'quantity': number;
        'runs': number;
        'time_efficiency': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_bookmarks_200 = Array < {
        'bookmark_id': number;
        'coordinates' ? : {
            'x': number;
            'y': number;
            'z': number;
        } & {
            [key: string]: any;
        };
        'created': string;
        'creator_id': number;
        'folder_id' ? : number;
        'item' ? : {
            'item_id': number;
            'type_id': number;
        } & {
            [key: string]: any;
        };
        'label': string;
        'location_id': number;
        'notes': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_bookmarks_folders_200 = Array < {
        'folder_id': number;
        'name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_calendar_200 = Array < {
        'event_date' ? : string;
        'event_id' ? : number;
        'event_response' ? : "declined" | "not_responded" | "accepted" | "tentative";
        'importance' ? : number;
        'title' ? : string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_calendar_event_id_200 = {
    'date': string;
    'duration': number;
    'event_id': number;
    'importance': number;
    'owner_id': number;
    'owner_name': string;
    'owner_type': "eve_server" | "corporation" | "faction" | "character" | "alliance";
    'response': string;
    'text': string;
    'title': string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_calendar_event_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_calendar_event_id_attendees_200 = Array < {
        'character_id' ? : number;
        'event_response' ? : "declined" | "not_responded" | "accepted" | "tentative";
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_calendar_event_id_attendees_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_clones_200 = {
    'home_location' ? : {
        'location_id' ? : number;
        'location_type' ? : "station" | "structure";
    } & {
        [key: string]: any;
    };
    'jump_clones': Array < {
            'implants': Array < number >
            ;
            'jump_clone_id': number;
            'location_id': number;
            'location_type': "station" | "structure";
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'last_clone_jump_date' ? : string;
    'last_station_change_date' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_contacts_200 = Array < {
        'contact_id': number;
        'contact_type': "character" | "corporation" | "alliance" | "faction";
        'is_blocked' ? : boolean;
        'is_watched' ? : boolean;
        'label_ids' ? : Array < number >
        ;
        'standing': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_characters_character_id_contacts_201 = Array < number >
;

export type Response_post_characters_character_id_contacts_520 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_contacts_labels_200 = Array < {
        'label_id': number;
        'label_name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_contracts_200 = Array < {
        'acceptor_id': number;
        'assignee_id': number;
        'availability': "public" | "personal" | "corporation" | "alliance";
        'buyout' ? : number;
        'collateral' ? : number;
        'contract_id': number;
        'date_accepted' ? : string;
        'date_completed' ? : string;
        'date_expired': string;
        'date_issued': string;
        'days_to_complete' ? : number;
        'end_location_id' ? : number;
        'for_corporation': boolean;
        'issuer_corporation_id': number;
        'issuer_id': number;
        'price' ? : number;
        'reward' ? : number;
        'start_location_id' ? : number;
        'status': "outstanding" | "in_progress" | "finished_issuer" | "finished_contractor" | "finished" | "cancelled" | "rejected" | "failed" | "deleted" | "reversed";
        'title' ? : string;
        'type': "unknown" | "item_exchange" | "auction" | "courier" | "loan";
        'volume' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_contracts_contract_id_bids_200 = Array < {
        'amount': number;
        'bid_id': number;
        'bidder_id': number;
        'date_bid': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_contracts_contract_id_bids_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_contracts_contract_id_items_200 = Array < {
        'is_included': boolean;
        'is_singleton': boolean;
        'quantity': number;
        'raw_quantity' ? : number;
        'record_id': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_contracts_contract_id_items_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_corporationhistory_200 = Array < {
        'corporation_id': number;
        'is_deleted' ? : boolean;
        'record_id': number;
        'start_date': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_characters_character_id_cspa_201 = number;

export type Response_get_characters_character_id_fatigue_200 = {
    'jump_fatigue_expire_date' ? : string;
    'last_jump_date' ? : string;
    'last_update_date' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_fittings_200 = Array < {
        'description': string;
        'fitting_id': number;
        'items': Array < {
                'flag': "Cargo" | "DroneBay" | "FighterBay" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "Invalid" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "ServiceSlot0" | "ServiceSlot1" | "ServiceSlot2" | "ServiceSlot3" | "ServiceSlot4" | "ServiceSlot5" | "ServiceSlot6" | "ServiceSlot7" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3";
                'quantity': number;
                'type_id': number;
            } & {
                [key: string]: any;
            } >
        ;
        'name': string;
        'ship_type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_characters_character_id_fittings_201 = {
    'fitting_id': number;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_fleet_200 = {
    'fleet_id': number;
    'role': "fleet_commander" | "squad_commander" | "squad_member" | "wing_commander";
    'squad_id': number;
    'wing_id': number;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_fleet_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_fw_stats_200 = {
    'current_rank' ? : number;
    'enlisted_on' ? : string;
    'faction_id' ? : number;
    'highest_rank' ? : number;
    'kills': {
        'last_week': number;
        'total': number;
        'yesterday': number;
    } & {
        [key: string]: any;
    };
    'victory_points': {
        'last_week': number;
        'total': number;
        'yesterday': number;
    } & {
        [key: string]: any;
    };
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_implants_200 = Array < number >
;

export type Response_get_characters_character_id_industry_jobs_200 = Array < {
        'activity_id': number;
        'blueprint_id': number;
        'blueprint_location_id': number;
        'blueprint_type_id': number;
        'completed_character_id' ? : number;
        'completed_date' ? : string;
        'cost' ? : number;
        'duration': number;
        'end_date': string;
        'facility_id': number;
        'installer_id': number;
        'job_id': number;
        'licensed_runs' ? : number;
        'output_location_id': number;
        'pause_date' ? : string;
        'probability' ? : number;
        'product_type_id' ? : number;
        'runs': number;
        'start_date': string;
        'station_id': number;
        'status': "active" | "cancelled" | "delivered" | "paused" | "ready" | "reverted";
        'successful_runs' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_killmails_recent_200 = Array < {
        'killmail_hash': string;
        'killmail_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_location_200 = {
    'solar_system_id': number;
    'station_id' ? : number;
    'structure_id' ? : number;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_loyalty_points_200 = Array < {
        'corporation_id': number;
        'loyalty_points': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_mail_200 = Array < {
        'from' ? : number;
        'is_read' ? : boolean;
        'labels' ? : Array < number >
        ;
        'mail_id' ? : number;
        'recipients' ? : Array < {
                'recipient_id': number;
                'recipient_type': "alliance" | "character" | "corporation" | "mailing_list";
            } & {
                [key: string]: any;
            } >
        ;
        'subject' ? : string;
        'timestamp' ? : string;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_characters_character_id_mail_201 = number;

export type Response_post_characters_character_id_mail_520 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_mail_labels_200 = {
    'labels' ? : Array < {
            'color' ? : "#0000fe" | "#006634" | "#0099ff" | "#00ff33" | "#01ffff" | "#349800" | "#660066" | "#666666" | "#999999" | "#99ffff" | "#9a0000" | "#ccff9a" | "#e6e6e6" | "#fe0000" | "#ff6600" | "#ffff01" | "#ffffcd" | "#ffffff";
            'label_id' ? : number;
            'name' ? : string;
            'unread_count' ? : number;
        } & {
            [key: string]: any;
        } >
    ;
    'total_unread_count' ? : number;
} & {
    [key: string]: any;
};

export type Response_post_characters_character_id_mail_labels_201 = number;

export type Response_delete_characters_character_id_mail_labels_label_id_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_mail_lists_200 = Array < {
        'mailing_list_id': number;
        'name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_mail_mail_id_200 = {
    'body' ? : string;
    'from' ? : number;
    'labels' ? : Array < number >
    ;
    'read' ? : boolean;
    'recipients' ? : Array < {
            'recipient_id': number;
            'recipient_type': "alliance" | "character" | "corporation" | "mailing_list";
        } & {
            [key: string]: any;
        } >
    ;
    'subject' ? : string;
    'timestamp' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_mail_mail_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_medals_200 = Array < {
        'corporation_id': number;
        'date': string;
        'description': string;
        'graphics': Array < {
                'color' ? : number;
                'graphic': string;
                'layer': number;
                'part': number;
            } & {
                [key: string]: any;
            } >
        ;
        'issuer_id': number;
        'medal_id': number;
        'reason': string;
        'status': "public" | "private";
        'title': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_mining_200 = Array < {
        'date': string;
        'quantity': number;
        'solar_system_id': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_notifications_200 = Array < {
        'is_read' ? : boolean;
        'notification_id': number;
        'sender_id': number;
        'sender_type': "character" | "corporation" | "alliance" | "faction" | "other";
        'text' ? : string;
        'timestamp': string;
        'type': "AcceptedAlly" | "AcceptedSurrender" | "AllAnchoringMsg" | "AllMaintenanceBillMsg" | "AllStrucInvulnerableMsg" | "AllStructVulnerableMsg" | "AllWarCorpJoinedAllianceMsg" | "AllWarDeclaredMsg" | "AllWarInvalidatedMsg" | "AllWarRetractedMsg" | "AllWarSurrenderMsg" | "AllianceCapitalChanged" | "AllianceWarDeclaredV2" | "AllyContractCancelled" | "AllyJoinedWarAggressorMsg" | "AllyJoinedWarAllyMsg" | "AllyJoinedWarDefenderMsg" | "BattlePunishFriendlyFire" | "BillOutOfMoneyMsg" | "BillPaidCorpAllMsg" | "BountyClaimMsg" | "BountyESSShared" | "BountyESSTaken" | "BountyPlacedAlliance" | "BountyPlacedChar" | "BountyPlacedCorp" | "BountyYourBountyClaimed" | "BuddyConnectContactAdd" | "CharAppAcceptMsg" | "CharAppRejectMsg" | "CharAppWithdrawMsg" | "CharLeftCorpMsg" | "CharMedalMsg" | "CharTerminationMsg" | "CloneActivationMsg" | "CloneActivationMsg2" | "CloneMovedMsg" | "CloneRevokedMsg1" | "CloneRevokedMsg2" | "CombatOperationFinished" | "ContactAdd" | "ContactEdit" | "ContainerPasswordMsg" | "CorpAllBillMsg" | "CorpAppAcceptMsg" | "CorpAppInvitedMsg" | "CorpAppNewMsg" | "CorpAppRejectCustomMsg" | "CorpAppRejectMsg" | "CorpBecameWarEligible" | "CorpDividendMsg" | "CorpFriendlyFireDisableTimerCompleted" | "CorpFriendlyFireDisableTimerStarted" | "CorpFriendlyFireEnableTimerCompleted" | "CorpFriendlyFireEnableTimerStarted" | "CorpKicked" | "CorpLiquidationMsg" | "CorpNewCEOMsg" | "CorpNewsMsg" | "CorpNoLongerWarEligible" | "CorpOfficeExpirationMsg" | "CorpStructLostMsg" | "CorpTaxChangeMsg" | "CorpVoteCEORevokedMsg" | "CorpVoteMsg" | "CorpWarDeclaredMsg" | "CorpWarDeclaredV2" | "CorpWarFightingLegalMsg" | "CorpWarInvalidatedMsg" | "CorpWarRetractedMsg" | "CorpWarSurrenderMsg" | "CustomsMsg" | "DeclareWar" | "DistrictAttacked" | "DustAppAcceptedMsg" | "EntosisCaptureStarted" | "FWAllianceKickMsg" | "FWAllianceWarningMsg" | "FWCharKickMsg" | "FWCharRankGainMsg" | "FWCharRankLossMsg" | "FWCharWarningMsg" | "FWCorpJoinMsg" | "FWCorpKickMsg" | "FWCorpLeaveMsg" | "FWCorpWarningMsg" | "FacWarCorpJoinRequestMsg" | "FacWarCorpJoinWithdrawMsg" | "FacWarCorpLeaveRequestMsg" | "FacWarCorpLeaveWithdrawMsg" | "FacWarLPDisqualifiedEvent" | "FacWarLPDisqualifiedKill" | "FacWarLPPayoutEvent" | "FacWarLPPayoutKill" | "GameTimeAdded" | "GameTimeReceived" | "GameTimeSent" | "GiftReceived" | "IHubDestroyedByBillFailure" | "IncursionCompletedMsg" | "IndustryOperationFinished" | "IndustryTeamAuctionLost" | "IndustryTeamAuctionWon" | "InfrastructureHubBillAboutToExpire" | "InsuranceExpirationMsg" | "InsuranceFirstShipMsg" | "InsuranceInvalidatedMsg" | "InsuranceIssuedMsg" | "InsurancePayoutMsg" | "InvasionSystemLogin" | "JumpCloneDeletedMsg1" | "JumpCloneDeletedMsg2" | "KillReportFinalBlow" | "KillReportVictim" | "KillRightAvailable" | "KillRightAvailableOpen" | "KillRightEarned" | "KillRightUnavailable" | "KillRightUnavailableOpen" | "KillRightUsed" | "LocateCharMsg" | "MadeWarMutual" | "MercOfferRetractedMsg" | "MercOfferedNegotiationMsg" | "MissionOfferExpirationMsg" | "MissionTimeoutMsg" | "MoonminingAutomaticFracture" | "MoonminingExtractionCancelled" | "MoonminingExtractionFinished" | "MoonminingExtractionStarted" | "MoonminingLaserFired" | "MutualWarExpired" | "MutualWarInviteAccepted" | "MutualWarInviteRejected" | "MutualWarInviteSent" | "NPCStandingsGained" | "NPCStandingsLost" | "OfferToAllyRetracted" | "OfferedSurrender" | "OfferedToAlly" | "OldLscMessages" | "OperationFinished" | "OrbitalAttacked" | "OrbitalReinforced" | "OwnershipTransferred" | "RaffleCreated" | "RaffleExpired" | "RaffleFinished" | "ReimbursementMsg" | "ResearchMissionAvailableMsg" | "RetractsWar" | "SeasonalChallengeCompleted" | "SovAllClaimAquiredMsg" | "SovAllClaimLostMsg" | "SovCommandNodeEventStarted" | "SovCorpBillLateMsg" | "SovCorpClaimFailMsg" | "SovDisruptorMsg" | "SovStationEnteredFreeport" | "SovStructureDestroyed" | "SovStructureReinforced" | "SovStructureSelfDestructCancel" | "SovStructureSelfDestructFinished" | "SovStructureSelfDestructRequested" | "SovereigntyIHDamageMsg" | "SovereigntySBUDamageMsg" | "SovereigntyTCUDamageMsg" | "StationAggressionMsg1" | "StationAggressionMsg2" | "StationConquerMsg" | "StationServiceDisabled" | "StationServiceEnabled" | "StationStateChangeMsg" | "StoryLineMissionAvailableMsg" | "StructureAnchoring" | "StructureCourierContractChanged" | "StructureDestroyed" | "StructureFuelAlert" | "StructureItemsDelivered" | "StructureItemsMovedToSafety" | "StructureLostArmor" | "StructureLostShields" | "StructureOnline" | "StructureServicesOffline" | "StructureUnanchoring" | "StructureUnderAttack" | "StructureWentHighPower" | "StructureWentLowPower" | "StructuresJobsCancelled" | "StructuresJobsPaused" | "StructuresReinforcementChanged" | "TowerAlertMsg" | "TowerResourceAlertMsg" | "TransactionReversalMsg" | "TutorialMsg" | "WarAdopted " | "WarAllyInherited" | "WarAllyOfferDeclinedMsg" | "WarConcordInvalidates" | "WarDeclared" | "WarHQRemovedFromSpace" | "WarInherited" | "WarInvalid" | "WarRetracted" | "WarRetractedByConcord" | "WarSurrenderDeclinedMsg" | "WarSurrenderOfferMsg";
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_notifications_contacts_200 = Array < {
        'message': string;
        'notification_id': number;
        'send_date': string;
        'sender_character_id': number;
        'standing_level': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_online_200 = {
    'last_login' ? : string;
    'last_logout' ? : string;
    'logins' ? : number;
    'online': boolean;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_opportunities_200 = Array < {
        'completed_at': string;
        'task_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_orders_200 = Array < {
        'duration': number;
        'escrow' ? : number;
        'is_buy_order' ? : boolean;
        'is_corporation': boolean;
        'issued': string;
        'location_id': number;
        'min_volume' ? : number;
        'order_id': number;
        'price': number;
        'range': "1" | "10" | "2" | "20" | "3" | "30" | "4" | "40" | "5" | "region" | "solarsystem" | "station";
        'region_id': number;
        'type_id': number;
        'volume_remain': number;
        'volume_total': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_orders_history_200 = Array < {
        'duration': number;
        'escrow' ? : number;
        'is_buy_order' ? : boolean;
        'is_corporation': boolean;
        'issued': string;
        'location_id': number;
        'min_volume' ? : number;
        'order_id': number;
        'price': number;
        'range': "1" | "10" | "2" | "20" | "3" | "30" | "4" | "40" | "5" | "region" | "solarsystem" | "station";
        'region_id': number;
        'state': "cancelled" | "expired";
        'type_id': number;
        'volume_remain': number;
        'volume_total': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_planets_200 = Array < {
        'last_update': string;
        'num_pins': number;
        'owner_id': number;
        'planet_id': number;
        'planet_type': "temperate" | "barren" | "oceanic" | "ice" | "gas" | "lava" | "storm" | "plasma";
        'solar_system_id': number;
        'upgrade_level': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_planets_planet_id_200 = {
    'links': Array < {
            'destination_pin_id': number;
            'link_level': number;
            'source_pin_id': number;
        } & {
            [key: string]: any;
        } >
    ;
    'pins': Array < {
            'contents' ? : Array < {
                    'amount': number;
                    'type_id': number;
                } & {
                    [key: string]: any;
                } >
            ;
            'expiry_time' ? : string;
            'extractor_details' ? : {
                'cycle_time' ? : number;
                'head_radius' ? : number;
                'heads': Array < {
                        'head_id': number;
                        'latitude': number;
                        'longitude': number;
                    } & {
                        [key: string]: any;
                    } >
                ;
                'product_type_id' ? : number;
                'qty_per_cycle' ? : number;
            } & {
                [key: string]: any;
            };
            'factory_details' ? : {
                'schematic_id': number;
            } & {
                [key: string]: any;
            };
            'install_time' ? : string;
            'last_cycle_start' ? : string;
            'latitude': number;
            'longitude': number;
            'pin_id': number;
            'schematic_id' ? : number;
            'type_id': number;
        } & {
            [key: string]: any;
        } >
    ;
    'routes': Array < {
            'content_type_id': number;
            'destination_pin_id': number;
            'quantity': number;
            'route_id': number;
            'source_pin_id': number;
            'waypoints' ? : Array < number >
            ;
        } & {
            [key: string]: any;
        } >
    ;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_planets_planet_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_portrait_200 = {
    'px128x128' ? : string;
    'px256x256' ? : string;
    'px512x512' ? : string;
    'px64x64' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_portrait_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_roles_200 = {
    'roles' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
    ;
    'roles_at_base' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
    ;
    'roles_at_hq' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
    ;
    'roles_at_other' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
    ;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_search_200 = {
    'agent' ? : Array < number >
    ;
    'alliance' ? : Array < number >
    ;
    'character' ? : Array < number >
    ;
    'constellation' ? : Array < number >
    ;
    'corporation' ? : Array < number >
    ;
    'faction' ? : Array < number >
    ;
    'inventory_type' ? : Array < number >
    ;
    'region' ? : Array < number >
    ;
    'solar_system' ? : Array < number >
    ;
    'station' ? : Array < number >
    ;
    'structure' ? : Array < number >
    ;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_ship_200 = {
    'ship_item_id': number;
    'ship_name': string;
    'ship_type_id': number;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_skillqueue_200 = Array < {
        'finish_date' ? : string;
        'finished_level': number;
        'level_end_sp' ? : number;
        'level_start_sp' ? : number;
        'queue_position': number;
        'skill_id': number;
        'start_date' ? : string;
        'training_start_sp' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_skills_200 = {
    'skills': Array < {
            'active_skill_level': number;
            'skill_id': number;
            'skillpoints_in_skill': number;
            'trained_skill_level': number;
        } & {
            [key: string]: any;
        } >
    ;
    'total_sp': number;
    'unallocated_sp' ? : number;
} & {
    [key: string]: any;
};

export type Response_get_characters_character_id_standings_200 = Array < {
        'from_id': number;
        'from_type': "agent" | "npc_corp" | "faction";
        'standing': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_stats_200 = Array < {
        'character' ? : {
            'days_of_activity' ? : number;
            'minutes' ? : number;
            'sessions_started' ? : number;
        } & {
            [key: string]: any;
        };
        'combat' ? : {
            'cap_drainedby_npc' ? : number;
            'cap_drainedby_pc' ? : number;
            'cap_draining_pc' ? : number;
            'criminal_flag_set' ? : number;
            'damage_from_np_cs_amount' ? : number;
            'damage_from_np_cs_num_shots' ? : number;
            'damage_from_players_bomb_amount' ? : number;
            'damage_from_players_bomb_num_shots' ? : number;
            'damage_from_players_combat_drone_amount' ? : number;
            'damage_from_players_combat_drone_num_shots' ? : number;
            'damage_from_players_energy_amount' ? : number;
            'damage_from_players_energy_num_shots' ? : number;
            'damage_from_players_fighter_bomber_amount' ? : number;
            'damage_from_players_fighter_bomber_num_shots' ? : number;
            'damage_from_players_fighter_drone_amount' ? : number;
            'damage_from_players_fighter_drone_num_shots' ? : number;
            'damage_from_players_hybrid_amount' ? : number;
            'damage_from_players_hybrid_num_shots' ? : number;
            'damage_from_players_missile_amount' ? : number;
            'damage_from_players_missile_num_shots' ? : number;
            'damage_from_players_projectile_amount' ? : number;
            'damage_from_players_projectile_num_shots' ? : number;
            'damage_from_players_smart_bomb_amount' ? : number;
            'damage_from_players_smart_bomb_num_shots' ? : number;
            'damage_from_players_super_amount' ? : number;
            'damage_from_players_super_num_shots' ? : number;
            'damage_from_structures_total_amount' ? : number;
            'damage_from_structures_total_num_shots' ? : number;
            'damage_to_players_bomb_amount' ? : number;
            'damage_to_players_bomb_num_shots' ? : number;
            'damage_to_players_combat_drone_amount' ? : number;
            'damage_to_players_combat_drone_num_shots' ? : number;
            'damage_to_players_energy_amount' ? : number;
            'damage_to_players_energy_num_shots' ? : number;
            'damage_to_players_fighter_bomber_amount' ? : number;
            'damage_to_players_fighter_bomber_num_shots' ? : number;
            'damage_to_players_fighter_drone_amount' ? : number;
            'damage_to_players_fighter_drone_num_shots' ? : number;
            'damage_to_players_hybrid_amount' ? : number;
            'damage_to_players_hybrid_num_shots' ? : number;
            'damage_to_players_missile_amount' ? : number;
            'damage_to_players_missile_num_shots' ? : number;
            'damage_to_players_projectile_amount' ? : number;
            'damage_to_players_projectile_num_shots' ? : number;
            'damage_to_players_smart_bomb_amount' ? : number;
            'damage_to_players_smart_bomb_num_shots' ? : number;
            'damage_to_players_super_amount' ? : number;
            'damage_to_players_super_num_shots' ? : number;
            'damage_to_structures_total_amount' ? : number;
            'damage_to_structures_total_num_shots' ? : number;
            'deaths_high_sec' ? : number;
            'deaths_low_sec' ? : number;
            'deaths_null_sec' ? : number;
            'deaths_pod_high_sec' ? : number;
            'deaths_pod_low_sec' ? : number;
            'deaths_pod_null_sec' ? : number;
            'deaths_pod_wormhole' ? : number;
            'deaths_wormhole' ? : number;
            'drone_engage' ? : number;
            'dscans' ? : number;
            'duel_requested' ? : number;
            'engagement_register' ? : number;
            'kills_assists' ? : number;
            'kills_high_sec' ? : number;
            'kills_low_sec' ? : number;
            'kills_null_sec' ? : number;
            'kills_pod_high_sec' ? : number;
            'kills_pod_low_sec' ? : number;
            'kills_pod_null_sec' ? : number;
            'kills_pod_wormhole' ? : number;
            'kills_wormhole' ? : number;
            'npc_flag_set' ? : number;
            'probe_scans' ? : number;
            'pvp_flag_set' ? : number;
            'repair_armor_by_remote_amount' ? : number;
            'repair_armor_remote_amount' ? : number;
            'repair_armor_self_amount' ? : number;
            'repair_capacitor_by_remote_amount' ? : number;
            'repair_capacitor_remote_amount' ? : number;
            'repair_capacitor_self_amount' ? : number;
            'repair_hull_by_remote_amount' ? : number;
            'repair_hull_remote_amount' ? : number;
            'repair_hull_self_amount' ? : number;
            'repair_shield_by_remote_amount' ? : number;
            'repair_shield_remote_amount' ? : number;
            'repair_shield_self_amount' ? : number;
            'self_destructs' ? : number;
            'warp_scramble_pc' ? : number;
            'warp_scrambledby_npc' ? : number;
            'warp_scrambledby_pc' ? : number;
            'weapon_flag_set' ? : number;
            'webifiedby_npc' ? : number;
            'webifiedby_pc' ? : number;
            'webifying_pc' ? : number;
        } & {
            [key: string]: any;
        };
        'industry' ? : {
            'hacking_successes' ? : number;
            'jobs_cancelled' ? : number;
            'jobs_completed_copy_blueprint' ? : number;
            'jobs_completed_invention' ? : number;
            'jobs_completed_manufacture' ? : number;
            'jobs_completed_manufacture_asteroid' ? : number;
            'jobs_completed_manufacture_asteroid_quantity' ? : number;
            'jobs_completed_manufacture_charge' ? : number;
            'jobs_completed_manufacture_charge_quantity' ? : number;
            'jobs_completed_manufacture_commodity' ? : number;
            'jobs_completed_manufacture_commodity_quantity' ? : number;
            'jobs_completed_manufacture_deployable' ? : number;
            'jobs_completed_manufacture_deployable_quantity' ? : number;
            'jobs_completed_manufacture_drone' ? : number;
            'jobs_completed_manufacture_drone_quantity' ? : number;
            'jobs_completed_manufacture_implant' ? : number;
            'jobs_completed_manufacture_implant_quantity' ? : number;
            'jobs_completed_manufacture_module' ? : number;
            'jobs_completed_manufacture_module_quantity' ? : number;
            'jobs_completed_manufacture_other' ? : number;
            'jobs_completed_manufacture_other_quantity' ? : number;
            'jobs_completed_manufacture_ship' ? : number;
            'jobs_completed_manufacture_ship_quantity' ? : number;
            'jobs_completed_manufacture_structure' ? : number;
            'jobs_completed_manufacture_structure_quantity' ? : number;
            'jobs_completed_manufacture_subsystem' ? : number;
            'jobs_completed_manufacture_subsystem_quantity' ? : number;
            'jobs_completed_material_productivity' ? : number;
            'jobs_completed_time_productivity' ? : number;
            'jobs_started_copy_blueprint' ? : number;
            'jobs_started_invention' ? : number;
            'jobs_started_manufacture' ? : number;
            'jobs_started_material_productivity' ? : number;
            'jobs_started_time_productivity' ? : number;
            'reprocess_item' ? : number;
            'reprocess_item_quantity' ? : number;
        } & {
            [key: string]: any;
        };
        'inventory' ? : {
            'abandon_loot_quantity' ? : number;
            'trash_item_quantity' ? : number;
        } & {
            [key: string]: any;
        };
        'isk' ? : {
            'in' ? : number;
            'out' ? : number;
        } & {
            [key: string]: any;
        };
        'market' ? : {
            'accept_contracts_courier' ? : number;
            'accept_contracts_item_exchange' ? : number;
            'buy_orders_placed' ? : number;
            'cancel_market_order' ? : number;
            'create_contracts_auction' ? : number;
            'create_contracts_courier' ? : number;
            'create_contracts_item_exchange' ? : number;
            'deliver_courier_contract' ? : number;
            'isk_gained' ? : number;
            'isk_spent' ? : number;
            'modify_market_order' ? : number;
            'search_contracts' ? : number;
            'sell_orders_placed' ? : number;
        } & {
            [key: string]: any;
        };
        'mining' ? : {
            'drone_mine' ? : number;
            'ore_arkonor' ? : number;
            'ore_bistot' ? : number;
            'ore_crokite' ? : number;
            'ore_dark_ochre' ? : number;
            'ore_gneiss' ? : number;
            'ore_harvestable_cloud' ? : number;
            'ore_hedbergite' ? : number;
            'ore_hemorphite' ? : number;
            'ore_ice' ? : number;
            'ore_jaspet' ? : number;
            'ore_kernite' ? : number;
            'ore_mercoxit' ? : number;
            'ore_omber' ? : number;
            'ore_plagioclase' ? : number;
            'ore_pyroxeres' ? : number;
            'ore_scordite' ? : number;
            'ore_spodumain' ? : number;
            'ore_veldspar' ? : number;
        } & {
            [key: string]: any;
        };
        'module' ? : {
            'activations_armor_hardener' ? : number;
            'activations_armor_repair_unit' ? : number;
            'activations_armor_resistance_shift_hardener' ? : number;
            'activations_automated_targeting_system' ? : number;
            'activations_bastion' ? : number;
            'activations_bomb_launcher' ? : number;
            'activations_capacitor_booster' ? : number;
            'activations_cargo_scanner' ? : number;
            'activations_cloaking_device' ? : number;
            'activations_clone_vat_bay' ? : number;
            'activations_cynosural_field' ? : number;
            'activations_damage_control' ? : number;
            'activations_data_miners' ? : number;
            'activations_drone_control_unit' ? : number;
            'activations_drone_tracking_modules' ? : number;
            'activations_eccm' ? : number;
            'activations_ecm' ? : number;
            'activations_ecm_burst' ? : number;
            'activations_energy_destabilizer' ? : number;
            'activations_energy_vampire' ? : number;
            'activations_energy_weapon' ? : number;
            'activations_festival_launcher' ? : number;
            'activations_frequency_mining_laser' ? : number;
            'activations_fueled_armor_repairer' ? : number;
            'activations_fueled_shield_booster' ? : number;
            'activations_gang_coordinator' ? : number;
            'activations_gas_cloud_harvester' ? : number;
            'activations_hull_repair_unit' ? : number;
            'activations_hybrid_weapon' ? : number;
            'activations_industrial_core' ? : number;
            'activations_interdiction_sphere_launcher' ? : number;
            'activations_micro_jump_drive' ? : number;
            'activations_mining_laser' ? : number;
            'activations_missile_launcher' ? : number;
            'activations_passive_targeting_system' ? : number;
            'activations_probe_launcher' ? : number;
            'activations_projected_eccm' ? : number;
            'activations_projectile_weapon' ? : number;
            'activations_propulsion_module' ? : number;
            'activations_remote_armor_repairer' ? : number;
            'activations_remote_capacitor_transmitter' ? : number;
            'activations_remote_ecm_burst' ? : number;
            'activations_remote_hull_repairer' ? : number;
            'activations_remote_sensor_booster' ? : number;
            'activations_remote_sensor_damper' ? : number;
            'activations_remote_shield_booster' ? : number;
            'activations_remote_tracking_computer' ? : number;
            'activations_salvager' ? : number;
            'activations_sensor_booster' ? : number;
            'activations_shield_booster' ? : number;
            'activations_shield_hardener' ? : number;
            'activations_ship_scanner' ? : number;
            'activations_siege' ? : number;
            'activations_smart_bomb' ? : number;
            'activations_stasis_web' ? : number;
            'activations_strip_miner' ? : number;
            'activations_super_weapon' ? : number;
            'activations_survey_scanner' ? : number;
            'activations_target_breaker' ? : number;
            'activations_target_painter' ? : number;
            'activations_tracking_computer' ? : number;
            'activations_tracking_disruptor' ? : number;
            'activations_tractor_beam' ? : number;
            'activations_triage' ? : number;
            'activations_warp_disrupt_field_generator' ? : number;
            'activations_warp_scrambler' ? : number;
            'link_weapons' ? : number;
            'overload' ? : number;
            'repairs' ? : number;
        } & {
            [key: string]: any;
        };
        'orbital' ? : {
            'strike_characters_killed' ? : number;
            'strike_damage_to_players_armor_amount' ? : number;
            'strike_damage_to_players_shield_amount' ? : number;
        } & {
            [key: string]: any;
        };
        'pve' ? : {
            'dungeons_completed_agent' ? : number;
            'dungeons_completed_distribution' ? : number;
            'missions_succeeded' ? : number;
            'missions_succeeded_epic_arc' ? : number;
        } & {
            [key: string]: any;
        };
        'social' ? : {
            'add_contact_bad' ? : number;
            'add_contact_good' ? : number;
            'add_contact_high' ? : number;
            'add_contact_horrible' ? : number;
            'add_contact_neutral' ? : number;
            'add_note' ? : number;
            'added_as_contact_bad' ? : number;
            'added_as_contact_good' ? : number;
            'added_as_contact_high' ? : number;
            'added_as_contact_horrible' ? : number;
            'added_as_contact_neutral' ? : number;
            'calendar_event_created' ? : number;
            'chat_messages_alliance' ? : number;
            'chat_messages_constellation' ? : number;
            'chat_messages_corporation' ? : number;
            'chat_messages_fleet' ? : number;
            'chat_messages_region' ? : number;
            'chat_messages_solarsystem' ? : number;
            'chat_messages_warfaction' ? : number;
            'chat_total_message_length' ? : number;
            'direct_trades' ? : number;
            'fleet_broadcasts' ? : number;
            'fleet_joins' ? : number;
            'mails_received' ? : number;
            'mails_sent' ? : number;
        } & {
            [key: string]: any;
        };
        'travel' ? : {
            'acceleration_gate_activations' ? : number;
            'align_to' ? : number;
            'distance_warped_high_sec' ? : number;
            'distance_warped_low_sec' ? : number;
            'distance_warped_null_sec' ? : number;
            'distance_warped_wormhole' ? : number;
            'docks_high_sec' ? : number;
            'docks_low_sec' ? : number;
            'docks_null_sec' ? : number;
            'jumps_stargate_high_sec' ? : number;
            'jumps_stargate_low_sec' ? : number;
            'jumps_stargate_null_sec' ? : number;
            'jumps_wormhole' ? : number;
            'warps_high_sec' ? : number;
            'warps_low_sec' ? : number;
            'warps_null_sec' ? : number;
            'warps_to_bookmark' ? : number;
            'warps_to_celestial' ? : number;
            'warps_to_fleet_member' ? : number;
            'warps_to_scan_result' ? : number;
            'warps_wormhole' ? : number;
        } & {
            [key: string]: any;
        };
        'year': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_titles_200 = Array < {
        'name' ? : string;
        'title_id' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_wallet_200 = number;

export type Response_get_characters_character_id_wallet_journal_200 = Array < {
        'amount' ? : number;
        'balance' ? : number;
        'context_id' ? : number;
        'context_id_type' ? : "structure_id" | "station_id" | "market_transaction_id" | "character_id" | "corporation_id" | "alliance_id" | "eve_system" | "industry_job_id" | "contract_id" | "planet_id" | "system_id" | "type_id";
        'date': string;
        'description': string;
        'first_party_id' ? : number;
        'id': number;
        'reason' ? : string;
        'ref_type': "acceleration_gate_fee" | "advertisement_listing_fee" | "agent_donation" | "agent_location_services" | "agent_miscellaneous" | "agent_mission_collateral_paid" | "agent_mission_collateral_refunded" | "agent_mission_reward" | "agent_mission_reward_corporation_tax" | "agent_mission_time_bonus_reward" | "agent_mission_time_bonus_reward_corporation_tax" | "agent_security_services" | "agent_services_rendered" | "agents_preward" | "alliance_maintainance_fee" | "alliance_registration_fee" | "asset_safety_recovery_tax" | "bounty" | "bounty_prize" | "bounty_prize_corporation_tax" | "bounty_prizes" | "bounty_reimbursement" | "bounty_surcharge" | "brokers_fee" | "clone_activation" | "clone_transfer" | "contraband_fine" | "contract_auction_bid" | "contract_auction_bid_corp" | "contract_auction_bid_refund" | "contract_auction_sold" | "contract_brokers_fee" | "contract_brokers_fee_corp" | "contract_collateral" | "contract_collateral_deposited_corp" | "contract_collateral_payout" | "contract_collateral_refund" | "contract_deposit" | "contract_deposit_corp" | "contract_deposit_refund" | "contract_deposit_sales_tax" | "contract_price" | "contract_price_payment_corp" | "contract_reversal" | "contract_reward" | "contract_reward_deposited" | "contract_reward_deposited_corp" | "contract_reward_refund" | "contract_sales_tax" | "copying" | "corporate_reward_payout" | "corporate_reward_tax" | "corporation_account_withdrawal" | "corporation_bulk_payment" | "corporation_dividend_payment" | "corporation_liquidation" | "corporation_logo_change_cost" | "corporation_payment" | "corporation_registration_fee" | "courier_mission_escrow" | "cspa" | "cspaofflinerefund" | "datacore_fee" | "dna_modification_fee" | "docking_fee" | "duel_wager_escrow" | "duel_wager_payment" | "duel_wager_refund" | "factory_slot_rental_fee" | "gm_cash_transfer" | "industry_job_tax" | "infrastructure_hub_maintenance" | "inheritance" | "insurance" | "item_trader_payment" | "jump_clone_activation_fee" | "jump_clone_installation_fee" | "kill_right_fee" | "lp_store" | "manufacturing" | "market_escrow" | "market_fine_paid" | "market_transaction" | "medal_creation" | "medal_issued" | "mission_completion" | "mission_cost" | "mission_expiration" | "mission_reward" | "office_rental_fee" | "operation_bonus" | "opportunity_reward" | "planetary_construction" | "planetary_export_tax" | "planetary_import_tax" | "player_donation" | "player_trading" | "project_discovery_reward" | "project_discovery_tax" | "reaction" | "release_of_impounded_property" | "repair_bill" | "reprocessing_tax" | "researching_material_productivity" | "researching_technology" | "researching_time_productivity" | "resource_wars_reward" | "reverse_engineering" | "security_processing_fee" | "shares" | "skill_purchase" | "sovereignity_bill" | "store_purchase" | "store_purchase_refund" | "structure_gate_jump" | "transaction_tax" | "upkeep_adjustment_fee" | "war_ally_contract" | "war_fee" | "war_fee_surrender";
        'second_party_id' ? : number;
        'tax' ? : number;
        'tax_receiver_id' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_characters_character_id_wallet_transactions_200 = Array < {
        'client_id': number;
        'date': string;
        'is_buy': boolean;
        'is_personal': boolean;
        'journal_ref_id': number;
        'location_id': number;
        'quantity': number;
        'transaction_id': number;
        'type_id': number;
        'unit_price': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_contracts_public_bids_contract_id_200 = Array < {
        'amount': number;
        'bid_id': number;
        'date_bid': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_contracts_public_bids_contract_id_403 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_contracts_public_bids_contract_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_contracts_public_items_contract_id_200 = Array < {
        'is_blueprint_copy' ? : boolean;
        'is_included': boolean;
        'item_id' ? : number;
        'material_efficiency' ? : number;
        'quantity': number;
        'record_id': number;
        'runs' ? : number;
        'time_efficiency' ? : number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_contracts_public_items_contract_id_403 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_contracts_public_items_contract_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_contracts_public_region_id_200 = Array < {
        'buyout' ? : number;
        'collateral' ? : number;
        'contract_id': number;
        'date_expired': string;
        'date_issued': string;
        'days_to_complete' ? : number;
        'end_location_id' ? : number;
        'for_corporation' ? : boolean;
        'issuer_corporation_id': number;
        'issuer_id': number;
        'price' ? : number;
        'reward' ? : number;
        'start_location_id' ? : number;
        'title' ? : string;
        'type': "unknown" | "item_exchange" | "auction" | "courier" | "loan";
        'volume' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_contracts_public_region_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporation_corporation_id_mining_extractions_200 = Array < {
        'chunk_arrival_time': string;
        'extraction_start_time': string;
        'moon_id': number;
        'natural_decay_time': string;
        'structure_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporation_corporation_id_mining_observers_200 = Array < {
        'last_updated': string;
        'observer_id': number;
        'observer_type': "structure";
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporation_corporation_id_mining_observers_observer_id_200 = Array < {
        'character_id': number;
        'last_updated': string;
        'quantity': number;
        'recorded_corporation_id': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_npccorps_200 = Array < number >
;

export type Response_get_corporations_corporation_id_200 = {
    'alliance_id' ? : number;
    'ceo_id': number;
    'creator_id': number;
    'date_founded' ? : string;
    'description' ? : string;
    'faction_id' ? : number;
    'home_station_id' ? : number;
    'member_count': number;
    'name': string;
    'shares' ? : number;
    'tax_rate': number;
    'ticker': string;
    'url' ? : string;
    'war_eligible' ? : boolean;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_alliancehistory_200 = Array < {
        'alliance_id' ? : number;
        'is_deleted' ? : boolean;
        'record_id': number;
        'start_date': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_assets_200 = Array < {
        'is_blueprint_copy' ? : boolean;
        'is_singleton': boolean;
        'item_id': number;
        'location_flag': "AssetSafety" | "AutoFit" | "Bonus" | "Booster" | "BoosterBay" | "Capsule" | "Cargo" | "CorpDeliveries" | "CorpSAG1" | "CorpSAG2" | "CorpSAG3" | "CorpSAG4" | "CorpSAG5" | "CorpSAG6" | "CorpSAG7" | "CrateLoot" | "Deliveries" | "DroneBay" | "DustBattle" | "DustDatabank" | "FighterBay" | "FighterTube0" | "FighterTube1" | "FighterTube2" | "FighterTube3" | "FighterTube4" | "FleetHangar" | "Hangar" | "HangarAll" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "HiddenModifiers" | "Implant" | "Impounded" | "JunkyardReprocessed" | "JunkyardTrashed" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "Locked" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "OfficeFolder" | "Pilot" | "PlanetSurface" | "QuafeBay" | "Reward" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "RigSlot3" | "RigSlot4" | "RigSlot5" | "RigSlot6" | "RigSlot7" | "SecondaryStorage" | "ServiceSlot0" | "ServiceSlot1" | "ServiceSlot2" | "ServiceSlot3" | "ServiceSlot4" | "ServiceSlot5" | "ServiceSlot6" | "ServiceSlot7" | "ShipHangar" | "ShipOffline" | "Skill" | "SkillInTraining" | "SpecializedAmmoHold" | "SpecializedCommandCenterHold" | "SpecializedFuelBay" | "SpecializedGasHold" | "SpecializedIndustrialShipHold" | "SpecializedLargeShipHold" | "SpecializedMaterialBay" | "SpecializedMediumShipHold" | "SpecializedMineralHold" | "SpecializedOreHold" | "SpecializedPlanetaryCommoditiesHold" | "SpecializedSalvageHold" | "SpecializedShipHold" | "SpecializedSmallShipHold" | "StructureActive" | "StructureFuel" | "StructureInactive" | "StructureOffline" | "SubSystemBay" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3" | "SubSystemSlot4" | "SubSystemSlot5" | "SubSystemSlot6" | "SubSystemSlot7" | "Unlocked" | "Wallet" | "Wardrobe";
        'location_id': number;
        'location_type': "station" | "solar_system" | "item" | "other";
        'quantity': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_corporations_corporation_id_assets_locations_200 = Array < {
        'item_id': number;
        'position': {
            'x': number;
            'y': number;
            'z': number;
        } & {
            [key: string]: any;
        };
    } & {
        [key: string]: any;
    } >
;

export type Response_post_corporations_corporation_id_assets_locations_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_corporations_corporation_id_assets_names_200 = Array < {
        'item_id': number;
        'name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_corporations_corporation_id_assets_names_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_blueprints_200 = Array < {
        'item_id': number;
        'location_flag': "AssetSafety" | "AutoFit" | "Bonus" | "Booster" | "BoosterBay" | "Capsule" | "Cargo" | "CorpDeliveries" | "CorpSAG1" | "CorpSAG2" | "CorpSAG3" | "CorpSAG4" | "CorpSAG5" | "CorpSAG6" | "CorpSAG7" | "CrateLoot" | "Deliveries" | "DroneBay" | "DustBattle" | "DustDatabank" | "FighterBay" | "FighterTube0" | "FighterTube1" | "FighterTube2" | "FighterTube3" | "FighterTube4" | "FleetHangar" | "Hangar" | "HangarAll" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "HiddenModifiers" | "Implant" | "Impounded" | "JunkyardReprocessed" | "JunkyardTrashed" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "Locked" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "OfficeFolder" | "Pilot" | "PlanetSurface" | "QuafeBay" | "Reward" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "RigSlot3" | "RigSlot4" | "RigSlot5" | "RigSlot6" | "RigSlot7" | "SecondaryStorage" | "ServiceSlot0" | "ServiceSlot1" | "ServiceSlot2" | "ServiceSlot3" | "ServiceSlot4" | "ServiceSlot5" | "ServiceSlot6" | "ServiceSlot7" | "ShipHangar" | "ShipOffline" | "Skill" | "SkillInTraining" | "SpecializedAmmoHold" | "SpecializedCommandCenterHold" | "SpecializedFuelBay" | "SpecializedGasHold" | "SpecializedIndustrialShipHold" | "SpecializedLargeShipHold" | "SpecializedMaterialBay" | "SpecializedMediumShipHold" | "SpecializedMineralHold" | "SpecializedOreHold" | "SpecializedPlanetaryCommoditiesHold" | "SpecializedSalvageHold" | "SpecializedShipHold" | "SpecializedSmallShipHold" | "StructureActive" | "StructureFuel" | "StructureInactive" | "StructureOffline" | "SubSystemBay" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3" | "SubSystemSlot4" | "SubSystemSlot5" | "SubSystemSlot6" | "SubSystemSlot7" | "Unlocked" | "Wallet" | "Wardrobe";
        'location_id': number;
        'material_efficiency': number;
        'quantity': number;
        'runs': number;
        'time_efficiency': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_bookmarks_200 = Array < {
        'bookmark_id': number;
        'coordinates' ? : {
            'x': number;
            'y': number;
            'z': number;
        } & {
            [key: string]: any;
        };
        'created': string;
        'creator_id': number;
        'folder_id' ? : number;
        'item' ? : {
            'item_id': number;
            'type_id': number;
        } & {
            [key: string]: any;
        };
        'label': string;
        'location_id': number;
        'notes': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_bookmarks_folders_200 = Array < {
        'creator_id' ? : number;
        'folder_id': number;
        'name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_contacts_200 = Array < {
        'contact_id': number;
        'contact_type': "character" | "corporation" | "alliance" | "faction";
        'is_watched' ? : boolean;
        'label_ids' ? : Array < number >
        ;
        'standing': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_contacts_labels_200 = Array < {
        'label_id': number;
        'label_name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_containers_logs_200 = Array < {
        'action': "add" | "assemble" | "configure" | "enter_password" | "lock" | "move" | "repackage" | "set_name" | "set_password" | "unlock";
        'character_id': number;
        'container_id': number;
        'container_type_id': number;
        'location_flag': "AssetSafety" | "AutoFit" | "Bonus" | "Booster" | "BoosterBay" | "Capsule" | "Cargo" | "CorpDeliveries" | "CorpSAG1" | "CorpSAG2" | "CorpSAG3" | "CorpSAG4" | "CorpSAG5" | "CorpSAG6" | "CorpSAG7" | "CrateLoot" | "Deliveries" | "DroneBay" | "DustBattle" | "DustDatabank" | "FighterBay" | "FighterTube0" | "FighterTube1" | "FighterTube2" | "FighterTube3" | "FighterTube4" | "FleetHangar" | "Hangar" | "HangarAll" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "HiddenModifiers" | "Implant" | "Impounded" | "JunkyardReprocessed" | "JunkyardTrashed" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "Locked" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "OfficeFolder" | "Pilot" | "PlanetSurface" | "QuafeBay" | "Reward" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "RigSlot3" | "RigSlot4" | "RigSlot5" | "RigSlot6" | "RigSlot7" | "SecondaryStorage" | "ServiceSlot0" | "ServiceSlot1" | "ServiceSlot2" | "ServiceSlot3" | "ServiceSlot4" | "ServiceSlot5" | "ServiceSlot6" | "ServiceSlot7" | "ShipHangar" | "ShipOffline" | "Skill" | "SkillInTraining" | "SpecializedAmmoHold" | "SpecializedCommandCenterHold" | "SpecializedFuelBay" | "SpecializedGasHold" | "SpecializedIndustrialShipHold" | "SpecializedLargeShipHold" | "SpecializedMaterialBay" | "SpecializedMediumShipHold" | "SpecializedMineralHold" | "SpecializedOreHold" | "SpecializedPlanetaryCommoditiesHold" | "SpecializedSalvageHold" | "SpecializedShipHold" | "SpecializedSmallShipHold" | "StructureActive" | "StructureFuel" | "StructureInactive" | "StructureOffline" | "SubSystemBay" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3" | "SubSystemSlot4" | "SubSystemSlot5" | "SubSystemSlot6" | "SubSystemSlot7" | "Unlocked" | "Wallet" | "Wardrobe";
        'location_id': number;
        'logged_at': string;
        'new_config_bitmask' ? : number;
        'old_config_bitmask' ? : number;
        'password_type' ? : "config" | "general";
        'quantity' ? : number;
        'type_id' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_contracts_200 = Array < {
        'acceptor_id': number;
        'assignee_id': number;
        'availability': "public" | "personal" | "corporation" | "alliance";
        'buyout' ? : number;
        'collateral' ? : number;
        'contract_id': number;
        'date_accepted' ? : string;
        'date_completed' ? : string;
        'date_expired': string;
        'date_issued': string;
        'days_to_complete' ? : number;
        'end_location_id' ? : number;
        'for_corporation': boolean;
        'issuer_corporation_id': number;
        'issuer_id': number;
        'price' ? : number;
        'reward' ? : number;
        'start_location_id' ? : number;
        'status': "outstanding" | "in_progress" | "finished_issuer" | "finished_contractor" | "finished" | "cancelled" | "rejected" | "failed" | "deleted" | "reversed";
        'title' ? : string;
        'type': "unknown" | "item_exchange" | "auction" | "courier" | "loan";
        'volume' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_contracts_contract_id_bids_200 = Array < {
        'amount': number;
        'bid_id': number;
        'bidder_id': number;
        'date_bid': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_contracts_contract_id_bids_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_contracts_contract_id_items_200 = Array < {
        'is_included': boolean;
        'is_singleton': boolean;
        'quantity': number;
        'raw_quantity' ? : number;
        'record_id': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_contracts_contract_id_items_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_contracts_contract_id_items_520 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_customs_offices_200 = Array < {
        'alliance_tax_rate' ? : number;
        'allow_access_with_standings': boolean;
        'allow_alliance_access': boolean;
        'bad_standing_tax_rate' ? : number;
        'corporation_tax_rate' ? : number;
        'excellent_standing_tax_rate' ? : number;
        'good_standing_tax_rate' ? : number;
        'neutral_standing_tax_rate' ? : number;
        'office_id': number;
        'reinforce_exit_end': number;
        'reinforce_exit_start': number;
        'standing_level' ? : "bad" | "excellent" | "good" | "neutral" | "terrible";
        'system_id': number;
        'terrible_standing_tax_rate' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_divisions_200 = {
    'hangar' ? : Array < {
            'division' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'wallet' ? : Array < {
            'division' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_facilities_200 = Array < {
        'facility_id': number;
        'system_id': number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_fw_stats_200 = {
    'enlisted_on' ? : string;
    'faction_id' ? : number;
    'kills': {
        'last_week': number;
        'total': number;
        'yesterday': number;
    } & {
        [key: string]: any;
    };
    'pilots' ? : number;
    'victory_points': {
        'last_week': number;
        'total': number;
        'yesterday': number;
    } & {
        [key: string]: any;
    };
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_icons_200 = {
    'px128x128' ? : string;
    'px256x256' ? : string;
    'px64x64' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_icons_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_industry_jobs_200 = Array < {
        'activity_id': number;
        'blueprint_id': number;
        'blueprint_location_id': number;
        'blueprint_type_id': number;
        'completed_character_id' ? : number;
        'completed_date' ? : string;
        'cost' ? : number;
        'duration': number;
        'end_date': string;
        'facility_id': number;
        'installer_id': number;
        'job_id': number;
        'licensed_runs' ? : number;
        'location_id': number;
        'output_location_id': number;
        'pause_date' ? : string;
        'probability' ? : number;
        'product_type_id' ? : number;
        'runs': number;
        'start_date': string;
        'status': "active" | "cancelled" | "delivered" | "paused" | "ready" | "reverted";
        'successful_runs' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_killmails_recent_200 = Array < {
        'killmail_hash': string;
        'killmail_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_medals_200 = Array < {
        'created_at': string;
        'creator_id': number;
        'description': string;
        'medal_id': number;
        'title': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_medals_issued_200 = Array < {
        'character_id': number;
        'issued_at': string;
        'issuer_id': number;
        'medal_id': number;
        'reason': string;
        'status': "private" | "public";
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_members_200 = Array < number >
;

export type Response_get_corporations_corporation_id_members_limit_200 = number;

export type Response_get_corporations_corporation_id_members_titles_200 = Array < {
        'character_id': number;
        'titles': Array < number >
        ;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_membertracking_200 = Array < {
        'base_id' ? : number;
        'character_id': number;
        'location_id' ? : number;
        'logoff_date' ? : string;
        'logon_date' ? : string;
        'ship_type_id' ? : number;
        'start_date' ? : string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_orders_200 = Array < {
        'duration': number;
        'escrow' ? : number;
        'is_buy_order' ? : boolean;
        'issued': string;
        'issued_by': number;
        'location_id': number;
        'min_volume' ? : number;
        'order_id': number;
        'price': number;
        'range': "1" | "10" | "2" | "20" | "3" | "30" | "4" | "40" | "5" | "region" | "solarsystem" | "station";
        'region_id': number;
        'type_id': number;
        'volume_remain': number;
        'volume_total': number;
        'wallet_division': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_orders_history_200 = Array < {
        'duration': number;
        'escrow' ? : number;
        'is_buy_order' ? : boolean;
        'issued': string;
        'issued_by' ? : number;
        'location_id': number;
        'min_volume' ? : number;
        'order_id': number;
        'price': number;
        'range': "1" | "10" | "2" | "20" | "3" | "30" | "4" | "40" | "5" | "region" | "solarsystem" | "station";
        'region_id': number;
        'state': "cancelled" | "expired";
        'type_id': number;
        'volume_remain': number;
        'volume_total': number;
        'wallet_division': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_roles_200 = Array < {
        'character_id': number;
        'grantable_roles' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'grantable_roles_at_base' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'grantable_roles_at_hq' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'grantable_roles_at_other' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'roles' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'roles_at_base' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'roles_at_hq' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'roles_at_other' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_roles_history_200 = Array < {
        'changed_at': string;
        'character_id': number;
        'issuer_id': number;
        'new_roles': Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'old_roles': Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'role_type': "grantable_roles" | "grantable_roles_at_base" | "grantable_roles_at_hq" | "grantable_roles_at_other" | "roles" | "roles_at_base" | "roles_at_hq" | "roles_at_other";
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_shareholders_200 = Array < {
        'share_count': number;
        'shareholder_id': number;
        'shareholder_type': "character" | "corporation";
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_standings_200 = Array < {
        'from_id': number;
        'from_type': "agent" | "npc_corp" | "faction";
        'standing': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_starbases_200 = Array < {
        'moon_id' ? : number;
        'onlined_since' ? : string;
        'reinforced_until' ? : string;
        'starbase_id': number;
        'state' ? : "offline" | "online" | "onlining" | "reinforced" | "unanchoring";
        'system_id': number;
        'type_id': number;
        'unanchor_at' ? : string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_starbases_starbase_id_200 = {
    'allow_alliance_members': boolean;
    'allow_corporation_members': boolean;
    'anchor': "alliance_member" | "config_starbase_equipment_role" | "corporation_member" | "starbase_fuel_technician_role";
    'attack_if_at_war': boolean;
    'attack_if_other_security_status_dropping': boolean;
    'attack_security_status_threshold' ? : number;
    'attack_standing_threshold' ? : number;
    'fuel_bay_take': "alliance_member" | "config_starbase_equipment_role" | "corporation_member" | "starbase_fuel_technician_role";
    'fuel_bay_view': "alliance_member" | "config_starbase_equipment_role" | "corporation_member" | "starbase_fuel_technician_role";
    'fuels' ? : Array < {
            'quantity': number;
            'type_id': number;
        } & {
            [key: string]: any;
        } >
    ;
    'offline': "alliance_member" | "config_starbase_equipment_role" | "corporation_member" | "starbase_fuel_technician_role";
    'online': "alliance_member" | "config_starbase_equipment_role" | "corporation_member" | "starbase_fuel_technician_role";
    'unanchor': "alliance_member" | "config_starbase_equipment_role" | "corporation_member" | "starbase_fuel_technician_role";
    'use_alliance_standings': boolean;
} & {
    [key: string]: any;
};

export type Response_get_corporations_corporation_id_structures_200 = Array < {
        'corporation_id': number;
        'fuel_expires' ? : string;
        'next_reinforce_apply' ? : string;
        'next_reinforce_hour' ? : number;
        'next_reinforce_weekday' ? : number;
        'profile_id': number;
        'reinforce_hour': number;
        'reinforce_weekday' ? : number;
        'services' ? : Array < {
                'name': string;
                'state': "online" | "offline" | "cleanup";
            } & {
                [key: string]: any;
            } >
        ;
        'state': "anchor_vulnerable" | "anchoring" | "armor_reinforce" | "armor_vulnerable" | "deploy_vulnerable" | "fitting_invulnerable" | "hull_reinforce" | "hull_vulnerable" | "online_deprecated" | "onlining_vulnerable" | "shield_vulnerable" | "unanchored" | "unknown";
        'state_timer_end' ? : string;
        'state_timer_start' ? : string;
        'structure_id': number;
        'system_id': number;
        'type_id': number;
        'unanchors_at' ? : string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_titles_200 = Array < {
        'grantable_roles' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'grantable_roles_at_base' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'grantable_roles_at_hq' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'grantable_roles_at_other' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'name' ? : string;
        'roles' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'roles_at_base' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'roles_at_hq' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'roles_at_other' ? : Array < "Account_Take_1" | "Account_Take_2" | "Account_Take_3" | "Account_Take_4" | "Account_Take_5" | "Account_Take_6" | "Account_Take_7" | "Accountant" | "Auditor" | "Communications_Officer" | "Config_Equipment" | "Config_Starbase_Equipment" | "Container_Take_1" | "Container_Take_2" | "Container_Take_3" | "Container_Take_4" | "Container_Take_5" | "Container_Take_6" | "Container_Take_7" | "Contract_Manager" | "Diplomat" | "Director" | "Factory_Manager" | "Fitting_Manager" | "Hangar_Query_1" | "Hangar_Query_2" | "Hangar_Query_3" | "Hangar_Query_4" | "Hangar_Query_5" | "Hangar_Query_6" | "Hangar_Query_7" | "Hangar_Take_1" | "Hangar_Take_2" | "Hangar_Take_3" | "Hangar_Take_4" | "Hangar_Take_5" | "Hangar_Take_6" | "Hangar_Take_7" | "Junior_Accountant" | "Personnel_Manager" | "Rent_Factory_Facility" | "Rent_Office" | "Rent_Research_Facility" | "Security_Officer" | "Starbase_Defense_Operator" | "Starbase_Fuel_Technician" | "Station_Manager" | "Trader" >
        ;
        'title_id' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_wallets_200 = Array < {
        'balance': number;
        'division': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_wallets_division_journal_200 = Array < {
        'amount' ? : number;
        'balance' ? : number;
        'context_id' ? : number;
        'context_id_type' ? : "structure_id" | "station_id" | "market_transaction_id" | "character_id" | "corporation_id" | "alliance_id" | "eve_system" | "industry_job_id" | "contract_id" | "planet_id" | "system_id" | "type_id";
        'date': string;
        'description': string;
        'first_party_id' ? : number;
        'id': number;
        'reason' ? : string;
        'ref_type': "acceleration_gate_fee" | "advertisement_listing_fee" | "agent_donation" | "agent_location_services" | "agent_miscellaneous" | "agent_mission_collateral_paid" | "agent_mission_collateral_refunded" | "agent_mission_reward" | "agent_mission_reward_corporation_tax" | "agent_mission_time_bonus_reward" | "agent_mission_time_bonus_reward_corporation_tax" | "agent_security_services" | "agent_services_rendered" | "agents_preward" | "alliance_maintainance_fee" | "alliance_registration_fee" | "asset_safety_recovery_tax" | "bounty" | "bounty_prize" | "bounty_prize_corporation_tax" | "bounty_prizes" | "bounty_reimbursement" | "bounty_surcharge" | "brokers_fee" | "clone_activation" | "clone_transfer" | "contraband_fine" | "contract_auction_bid" | "contract_auction_bid_corp" | "contract_auction_bid_refund" | "contract_auction_sold" | "contract_brokers_fee" | "contract_brokers_fee_corp" | "contract_collateral" | "contract_collateral_deposited_corp" | "contract_collateral_payout" | "contract_collateral_refund" | "contract_deposit" | "contract_deposit_corp" | "contract_deposit_refund" | "contract_deposit_sales_tax" | "contract_price" | "contract_price_payment_corp" | "contract_reversal" | "contract_reward" | "contract_reward_deposited" | "contract_reward_deposited_corp" | "contract_reward_refund" | "contract_sales_tax" | "copying" | "corporate_reward_payout" | "corporate_reward_tax" | "corporation_account_withdrawal" | "corporation_bulk_payment" | "corporation_dividend_payment" | "corporation_liquidation" | "corporation_logo_change_cost" | "corporation_payment" | "corporation_registration_fee" | "courier_mission_escrow" | "cspa" | "cspaofflinerefund" | "datacore_fee" | "dna_modification_fee" | "docking_fee" | "duel_wager_escrow" | "duel_wager_payment" | "duel_wager_refund" | "factory_slot_rental_fee" | "gm_cash_transfer" | "industry_job_tax" | "infrastructure_hub_maintenance" | "inheritance" | "insurance" | "jump_clone_activation_fee" | "jump_clone_installation_fee" | "kill_right_fee" | "lp_store" | "manufacturing" | "market_escrow" | "market_fine_paid" | "market_transaction" | "medal_creation" | "medal_issued" | "mission_completion" | "mission_cost" | "mission_expiration" | "mission_reward" | "office_rental_fee" | "operation_bonus" | "opportunity_reward" | "planetary_construction" | "planetary_export_tax" | "planetary_import_tax" | "player_donation" | "player_trading" | "project_discovery_reward" | "project_discovery_tax" | "reaction" | "release_of_impounded_property" | "repair_bill" | "reprocessing_tax" | "researching_material_productivity" | "researching_technology" | "researching_time_productivity" | "resource_wars_reward" | "reverse_engineering" | "security_processing_fee" | "shares" | "sovereignity_bill" | "store_purchase" | "store_purchase_refund" | "structure_gate_jump" | "transaction_tax" | "upkeep_adjustment_fee" | "war_ally_contract" | "war_fee" | "war_fee_surrender";
        'second_party_id' ? : number;
        'tax' ? : number;
        'tax_receiver_id' ? : number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_corporations_corporation_id_wallets_division_transactions_200 = Array < {
        'client_id': number;
        'date': string;
        'is_buy': boolean;
        'journal_ref_id': number;
        'location_id': number;
        'quantity': number;
        'transaction_id': number;
        'type_id': number;
        'unit_price': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_dogma_attributes_200 = Array < number >
;

export type Response_get_dogma_attributes_attribute_id_200 = {
    'attribute_id': number;
    'default_value' ? : number;
    'description' ? : string;
    'display_name' ? : string;
    'high_is_good' ? : boolean;
    'icon_id' ? : number;
    'name' ? : string;
    'published' ? : boolean;
    'stackable' ? : boolean;
    'unit_id' ? : number;
} & {
    [key: string]: any;
};

export type Response_get_dogma_attributes_attribute_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_dogma_dynamic_items_type_id_item_id_200 = {
    'created_by': number;
    'dogma_attributes': Array < {
            'attribute_id': number;
            'value': number;
        } & {
            [key: string]: any;
        } >
    ;
    'dogma_effects': Array < {
            'effect_id': number;
            'is_default': boolean;
        } & {
            [key: string]: any;
        } >
    ;
    'mutator_type_id': number;
    'source_type_id': number;
} & {
    [key: string]: any;
};

export type Response_get_dogma_dynamic_items_type_id_item_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_dogma_effects_200 = Array < number >
;

export type Response_get_dogma_effects_effect_id_200 = {
    'description' ? : string;
    'disallow_auto_repeat' ? : boolean;
    'discharge_attribute_id' ? : number;
    'display_name' ? : string;
    'duration_attribute_id' ? : number;
    'effect_category' ? : number;
    'effect_id': number;
    'electronic_chance' ? : boolean;
    'falloff_attribute_id' ? : number;
    'icon_id' ? : number;
    'is_assistance' ? : boolean;
    'is_offensive' ? : boolean;
    'is_warp_safe' ? : boolean;
    'modifiers' ? : Array < {
            'domain' ? : string;
            'effect_id' ? : number;
            'func': string;
            'modified_attribute_id' ? : number;
            'modifying_attribute_id' ? : number;
            'operator' ? : number;
        } & {
            [key: string]: any;
        } >
    ;
    'name' ? : string;
    'post_expression' ? : number;
    'pre_expression' ? : number;
    'published' ? : boolean;
    'range_attribute_id' ? : number;
    'range_chance' ? : boolean;
    'tracking_speed_attribute_id' ? : number;
} & {
    [key: string]: any;
};

export type Response_get_dogma_effects_effect_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_fleets_fleet_id_200 = {
    'is_free_move': boolean;
    'is_registered': boolean;
    'is_voice_enabled': boolean;
    'motd': string;
} & {
    [key: string]: any;
};

export type Response_get_fleets_fleet_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_put_fleets_fleet_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_fleets_fleet_id_members_200 = Array < {
        'character_id': number;
        'join_time': string;
        'role': "fleet_commander" | "wing_commander" | "squad_commander" | "squad_member";
        'role_name': string;
        'ship_type_id': number;
        'solar_system_id': number;
        'squad_id': number;
        'station_id' ? : number;
        'takes_fleet_warp': boolean;
        'wing_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_fleets_fleet_id_members_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_fleets_fleet_id_members_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_fleets_fleet_id_members_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_delete_fleets_fleet_id_members_member_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_put_fleets_fleet_id_members_member_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_put_fleets_fleet_id_members_member_id_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_delete_fleets_fleet_id_squads_squad_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_put_fleets_fleet_id_squads_squad_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_fleets_fleet_id_wings_200 = Array < {
        'id': number;
        'name': string;
        'squads': Array < {
                'id': number;
                'name': string;
            } & {
                [key: string]: any;
            } >
        ;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_fleets_fleet_id_wings_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_fleets_fleet_id_wings_201 = {
    'wing_id': number;
} & {
    [key: string]: any;
};

export type Response_post_fleets_fleet_id_wings_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_delete_fleets_fleet_id_wings_wing_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_put_fleets_fleet_id_wings_wing_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_fleets_fleet_id_wings_wing_id_squads_201 = {
    'squad_id': number;
} & {
    [key: string]: any;
};

export type Response_post_fleets_fleet_id_wings_wing_id_squads_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_fw_leaderboards_200 = {
    'kills': {
        'active_total': Array < {
                'amount' ? : number;
                'faction_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'last_week': Array < {
                'amount' ? : number;
                'faction_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'yesterday': Array < {
                'amount' ? : number;
                'faction_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
    } & {
        [key: string]: any;
    };
    'victory_points': {
        'active_total': Array < {
                'amount' ? : number;
                'faction_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'last_week': Array < {
                'amount' ? : number;
                'faction_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'yesterday': Array < {
                'amount' ? : number;
                'faction_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
    } & {
        [key: string]: any;
    };
} & {
    [key: string]: any;
};

export type Response_get_fw_leaderboards_characters_200 = {
    'kills': {
        'active_total': Array < {
                'amount' ? : number;
                'character_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'last_week': Array < {
                'amount' ? : number;
                'character_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'yesterday': Array < {
                'amount' ? : number;
                'character_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
    } & {
        [key: string]: any;
    };
    'victory_points': {
        'active_total': Array < {
                'amount' ? : number;
                'character_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'last_week': Array < {
                'amount' ? : number;
                'character_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'yesterday': Array < {
                'amount' ? : number;
                'character_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
    } & {
        [key: string]: any;
    };
} & {
    [key: string]: any;
};

export type Response_get_fw_leaderboards_corporations_200 = {
    'kills': {
        'active_total': Array < {
                'amount' ? : number;
                'corporation_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'last_week': Array < {
                'amount' ? : number;
                'corporation_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'yesterday': Array < {
                'amount' ? : number;
                'corporation_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
    } & {
        [key: string]: any;
    };
    'victory_points': {
        'active_total': Array < {
                'amount' ? : number;
                'corporation_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'last_week': Array < {
                'amount' ? : number;
                'corporation_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
        'yesterday': Array < {
                'amount' ? : number;
                'corporation_id' ? : number;
            } & {
                [key: string]: any;
            } >
        ;
    } & {
        [key: string]: any;
    };
} & {
    [key: string]: any;
};

export type Response_get_fw_stats_200 = Array < {
        'faction_id': number;
        'kills': {
            'last_week': number;
            'total': number;
            'yesterday': number;
        } & {
            [key: string]: any;
        };
        'pilots': number;
        'systems_controlled': number;
        'victory_points': {
            'last_week': number;
            'total': number;
            'yesterday': number;
        } & {
            [key: string]: any;
        };
    } & {
        [key: string]: any;
    } >
;

export type Response_get_fw_systems_200 = Array < {
        'contested': "captured" | "contested" | "uncontested" | "vulnerable";
        'occupier_faction_id': number;
        'owner_faction_id': number;
        'solar_system_id': number;
        'victory_points': number;
        'victory_points_threshold': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_fw_wars_200 = Array < {
        'against_id': number;
        'faction_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_incursions_200 = Array < {
        'constellation_id': number;
        'faction_id': number;
        'has_boss': boolean;
        'infested_solar_systems': Array < number >
        ;
        'influence': number;
        'staging_solar_system_id': number;
        'state': "withdrawing" | "mobilizing" | "established";
        'type': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_industry_facilities_200 = Array < {
        'facility_id': number;
        'owner_id': number;
        'region_id': number;
        'solar_system_id': number;
        'tax' ? : number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_industry_systems_200 = Array < {
        'cost_indices': Array < {
                'activity': "copying" | "duplicating" | "invention" | "manufacturing" | "none" | "reaction" | "researching_material_efficiency" | "researching_technology" | "researching_time_efficiency" | "reverse_engineering";
                'cost_index': number;
            } & {
                [key: string]: any;
            } >
        ;
        'solar_system_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_insurance_prices_200 = Array < {
        'levels': Array < {
                'cost': number;
                'name': string;
                'payout': number;
            } & {
                [key: string]: any;
            } >
        ;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_killmails_killmail_id_killmail_hash_200 = {
    'attackers': Array < {
            'alliance_id' ? : number;
            'character_id' ? : number;
            'corporation_id' ? : number;
            'damage_done': number;
            'faction_id' ? : number;
            'final_blow': boolean;
            'security_status': number;
            'ship_type_id' ? : number;
            'weapon_type_id' ? : number;
        } & {
            [key: string]: any;
        } >
    ;
    'killmail_id': number;
    'killmail_time': string;
    'moon_id' ? : number;
    'solar_system_id': number;
    'victim': {
        'alliance_id' ? : number;
        'character_id' ? : number;
        'corporation_id' ? : number;
        'damage_taken': number;
        'faction_id' ? : number;
        'items' ? : Array < {
                'flag': number;
                'item_type_id': number;
                'items' ? : Array < {
                        'flag': number;
                        'item_type_id': number;
                        'quantity_destroyed' ? : number;
                        'quantity_dropped' ? : number;
                        'singleton': number;
                    } & {
                        [key: string]: any;
                    } >
                ;
                'quantity_destroyed' ? : number;
                'quantity_dropped' ? : number;
                'singleton': number;
            } & {
                [key: string]: any;
            } >
        ;
        'position' ? : {
            'x': number;
            'y': number;
            'z': number;
        } & {
            [key: string]: any;
        };
        'ship_type_id': number;
    } & {
        [key: string]: any;
    };
    'war_id' ? : number;
} & {
    [key: string]: any;
};

export type Response_get_killmails_killmail_id_killmail_hash_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_loyalty_stores_corporation_id_offers_200 = Array < {
        'ak_cost' ? : number;
        'isk_cost': number;
        'lp_cost': number;
        'offer_id': number;
        'quantity': number;
        'required_items': Array < {
                'quantity': number;
                'type_id': number;
            } & {
                [key: string]: any;
            } >
        ;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_loyalty_stores_corporation_id_offers_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_markets_groups_200 = Array < number >
;

export type Response_get_markets_groups_market_group_id_200 = {
    'description': string;
    'market_group_id': number;
    'name': string;
    'parent_group_id' ? : number;
    'types': Array < number >
    ;
} & {
    [key: string]: any;
};

export type Response_get_markets_groups_market_group_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_markets_prices_200 = Array < {
        'adjusted_price' ? : number;
        'average_price' ? : number;
        'type_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_markets_structures_structure_id_200 = Array < {
        'duration': number;
        'is_buy_order': boolean;
        'issued': string;
        'location_id': number;
        'min_volume': number;
        'order_id': number;
        'price': number;
        'range': "station" | "region" | "solarsystem" | "1" | "2" | "3" | "4" | "5" | "10" | "20" | "30" | "40";
        'type_id': number;
        'volume_remain': number;
        'volume_total': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_markets_region_id_history_200 = Array < {
        'average': number;
        'date': string;
        'highest': number;
        'lowest': number;
        'order_count': number;
        'volume': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_markets_region_id_history_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_markets_region_id_history_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_markets_region_id_history_520 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_markets_region_id_orders_200 = Array < {
        'duration': number;
        'is_buy_order': boolean;
        'issued': string;
        'location_id': number;
        'min_volume': number;
        'order_id': number;
        'price': number;
        'range': "station" | "region" | "solarsystem" | "1" | "2" | "3" | "4" | "5" | "10" | "20" | "30" | "40";
        'system_id': number;
        'type_id': number;
        'volume_remain': number;
        'volume_total': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_markets_region_id_orders_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_markets_region_id_orders_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_markets_region_id_types_200 = Array < number >
;

export type Response_get_opportunities_groups_200 = Array < number >
;

export type Response_get_opportunities_groups_group_id_200 = {
    'connected_groups': Array < number >
    ;
    'description': string;
    'group_id': number;
    'name': string;
    'notification': string;
    'required_tasks': Array < number >
    ;
} & {
    [key: string]: any;
};

export type Response_get_opportunities_tasks_200 = Array < number >
;

export type Response_get_opportunities_tasks_task_id_200 = {
    'description': string;
    'name': string;
    'notification': string;
    'task_id': number;
} & {
    [key: string]: any;
};

export type Response_get_route_origin_destination_200 = Array < number >
;

export type Response_get_route_origin_destination_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_search_200 = {
    'agent' ? : Array < number >
    ;
    'alliance' ? : Array < number >
    ;
    'character' ? : Array < number >
    ;
    'constellation' ? : Array < number >
    ;
    'corporation' ? : Array < number >
    ;
    'faction' ? : Array < number >
    ;
    'inventory_type' ? : Array < number >
    ;
    'region' ? : Array < number >
    ;
    'solar_system' ? : Array < number >
    ;
    'station' ? : Array < number >
    ;
} & {
    [key: string]: any;
};

export type Response_get_sovereignty_campaigns_200 = Array < {
        'attackers_score' ? : number;
        'campaign_id': number;
        'constellation_id': number;
        'defender_id' ? : number;
        'defender_score' ? : number;
        'event_type': "tcu_defense" | "ihub_defense" | "station_defense" | "station_freeport";
        'participants' ? : Array < {
                'alliance_id': number;
                'score': number;
            } & {
                [key: string]: any;
            } >
        ;
        'solar_system_id': number;
        'start_time': string;
        'structure_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_sovereignty_map_200 = Array < {
        'alliance_id' ? : number;
        'corporation_id' ? : number;
        'faction_id' ? : number;
        'system_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_sovereignty_structures_200 = Array < {
        'alliance_id': number;
        'solar_system_id': number;
        'structure_id': number;
        'structure_type_id': number;
        'vulnerability_occupancy_level' ? : number;
        'vulnerable_end_time' ? : string;
        'vulnerable_start_time' ? : string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_status_200 = {
    'players': number;
    'server_version': string;
    'start_time': string;
    'vip' ? : boolean;
} & {
    [key: string]: any;
};

export type Response_post_ui_openwindow_newmail_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_ancestries_200 = Array < {
        'bloodline_id': number;
        'description': string;
        'icon_id' ? : number;
        'id': number;
        'name': string;
        'short_description' ? : string;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_universe_asteroid_belts_asteroid_belt_id_200 = {
    'name': string;
    'position': {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'system_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_asteroid_belts_asteroid_belt_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_bloodlines_200 = Array < {
        'bloodline_id': number;
        'charisma': number;
        'corporation_id': number;
        'description': string;
        'intelligence': number;
        'memory': number;
        'name': string;
        'perception': number;
        'race_id': number;
        'ship_type_id': number;
        'willpower': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_universe_categories_200 = Array < number >
;

export type Response_get_universe_categories_category_id_200 = {
    'category_id': number;
    'groups': Array < number >
    ;
    'name': string;
    'published': boolean;
} & {
    [key: string]: any;
};

export type Response_get_universe_categories_category_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_constellations_200 = Array < number >
;

export type Response_get_universe_constellations_constellation_id_200 = {
    'constellation_id': number;
    'name': string;
    'position': {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'region_id': number;
    'systems': Array < number >
    ;
} & {
    [key: string]: any;
};

export type Response_get_universe_constellations_constellation_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_factions_200 = Array < {
        'corporation_id' ? : number;
        'description': string;
        'faction_id': number;
        'is_unique': boolean;
        'militia_corporation_id' ? : number;
        'name': string;
        'size_factor': number;
        'solar_system_id' ? : number;
        'station_count': number;
        'station_system_count': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_universe_graphics_200 = Array < number >
;

export type Response_get_universe_graphics_graphic_id_200 = {
    'collision_file' ? : string;
    'graphic_file' ? : string;
    'graphic_id': number;
    'icon_folder' ? : string;
    'sof_dna' ? : string;
    'sof_fation_name' ? : string;
    'sof_hull_name' ? : string;
    'sof_race_name' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_graphics_graphic_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_groups_200 = Array < number >
;

export type Response_get_universe_groups_group_id_200 = {
    'category_id': number;
    'group_id': number;
    'name': string;
    'published': boolean;
    'types': Array < number >
    ;
} & {
    [key: string]: any;
};

export type Response_get_universe_groups_group_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_universe_ids_200 = {
    'agents' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'alliances' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'characters' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'constellations' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'corporations' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'factions' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'inventory_types' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'regions' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'stations' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
    'systems' ? : Array < {
            'id' ? : number;
            'name' ? : string;
        } & {
            [key: string]: any;
        } >
    ;
} & {
    [key: string]: any;
};

export type Response_get_universe_moons_moon_id_200 = {
    'moon_id': number;
    'name': string;
    'position': {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'system_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_moons_moon_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_post_universe_names_200 = Array < {
        'category': "alliance" | "character" | "constellation" | "corporation" | "inventory_type" | "region" | "solar_system" | "station" | "faction";
        'id': number;
        'name': string;
    } & {
        [key: string]: any;
    } >
;

export type Response_post_universe_names_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_planets_planet_id_200 = {
    'name': string;
    'planet_id': number;
    'position': {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'system_id': number;
    'type_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_planets_planet_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_races_200 = Array < {
        'alliance_id': number;
        'description': string;
        'name': string;
        'race_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_universe_regions_200 = Array < number >
;

export type Response_get_universe_regions_region_id_200 = {
    'constellations': Array < number >
    ;
    'description' ? : string;
    'name': string;
    'region_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_regions_region_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_schematics_schematic_id_200 = {
    'cycle_time': number;
    'schematic_name': string;
} & {
    [key: string]: any;
};

export type Response_get_universe_schematics_schematic_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_stargates_stargate_id_200 = {
    'destination': {
        'stargate_id': number;
        'system_id': number;
    } & {
        [key: string]: any;
    };
    'name': string;
    'position': {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'stargate_id': number;
    'system_id': number;
    'type_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_stargates_stargate_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_stars_star_id_200 = {
    'age': number;
    'luminosity': number;
    'name': string;
    'radius': number;
    'solar_system_id': number;
    'spectral_class': "K2 V" | "K4 V" | "G2 V" | "G8 V" | "M7 V" | "K7 V" | "M2 V" | "K5 V" | "M3 V" | "G0 V" | "G7 V" | "G3 V" | "F9 V" | "G5 V" | "F6 V" | "K8 V" | "K9 V" | "K6 V" | "G9 V" | "G6 V" | "G4 VI" | "G4 V" | "F8 V" | "F2 V" | "F1 V" | "K3 V" | "F0 VI" | "G1 VI" | "G0 VI" | "K1 V" | "M4 V" | "M1 V" | "M6 V" | "M0 V" | "K2 IV" | "G2 VI" | "K0 V" | "K5 IV" | "F5 VI" | "G6 VI" | "F6 VI" | "F2 IV" | "G3 VI" | "M8 V" | "F1 VI" | "K1 IV" | "F7 V" | "G5 VI" | "M5 V" | "G7 VI" | "F5 V" | "F4 VI" | "F8 VI" | "K3 IV" | "F4 IV" | "F0 V" | "G7 IV" | "G8 VI" | "F2 VI" | "F4 V" | "F7 VI" | "F3 V" | "G1 V" | "G9 VI" | "F3 IV" | "F9 VI" | "M9 V" | "K0 IV" | "F1 IV" | "G4 IV" | "F3 VI" | "K4 IV" | "G5 IV" | "G3 IV" | "G1 IV" | "K7 IV" | "G0 IV" | "K6 IV" | "K9 IV" | "G2 IV" | "F9 IV" | "F0 IV" | "K8 IV" | "G8 IV" | "F6 IV" | "F5 IV" | "A0" | "A0IV" | "A0IV2";
    'temperature': number;
    'type_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_stations_station_id_200 = {
    'max_dockable_ship_volume': number;
    'name': string;
    'office_rental_cost': number;
    'owner' ? : number;
    'position': {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'race_id' ? : number;
    'reprocessing_efficiency': number;
    'reprocessing_stations_take': number;
    'services': Array < "bounty-missions" | "assasination-missions" | "courier-missions" | "interbus" | "reprocessing-plant" | "refinery" | "market" | "black-market" | "stock-exchange" | "cloning" | "surgery" | "dna-therapy" | "repair-facilities" | "factory" | "labratory" | "gambling" | "fitting" | "paintshop" | "news" | "storage" | "insurance" | "docking" | "office-rental" | "jump-clone-facility" | "loyalty-point-store" | "navy-offices" | "security-offices" >
    ;
    'station_id': number;
    'system_id': number;
    'type_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_stations_station_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_structures_200 = Array < number >
;

export type Response_get_universe_structures_structure_id_200 = {
    'name': string;
    'owner_id': number;
    'position' ? : {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'solar_system_id': number;
    'type_id' ? : number;
} & {
    [key: string]: any;
};

export type Response_get_universe_structures_structure_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_system_jumps_200 = Array < {
        'ship_jumps': number;
        'system_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_universe_system_kills_200 = Array < {
        'npc_kills': number;
        'pod_kills': number;
        'ship_kills': number;
        'system_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_universe_systems_200 = Array < number >
;

export type Response_get_universe_systems_system_id_200 = {
    'constellation_id': number;
    'name': string;
    'planets' ? : Array < {
            'asteroid_belts' ? : Array < number >
            ;
            'moons' ? : Array < number >
            ;
            'planet_id': number;
        } & {
            [key: string]: any;
        } >
    ;
    'position': {
        'x': number;
        'y': number;
        'z': number;
    } & {
        [key: string]: any;
    };
    'security_class' ? : string;
    'security_status': number;
    'star_id' ? : number;
    'stargates' ? : Array < number >
    ;
    'stations' ? : Array < number >
    ;
    'system_id': number;
} & {
    [key: string]: any;
};

export type Response_get_universe_systems_system_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_universe_types_200 = Array < number >
;

export type Response_get_universe_types_type_id_200 = {
    'capacity' ? : number;
    'description': string;
    'dogma_attributes' ? : Array < {
            'attribute_id': number;
            'value': number;
        } & {
            [key: string]: any;
        } >
    ;
    'dogma_effects' ? : Array < {
            'effect_id': number;
            'is_default': boolean;
        } & {
            [key: string]: any;
        } >
    ;
    'graphic_id' ? : number;
    'group_id': number;
    'icon_id' ? : number;
    'market_group_id' ? : number;
    'mass' ? : number;
    'name': string;
    'packaged_volume' ? : number;
    'portion_size' ? : number;
    'published': boolean;
    'radius' ? : number;
    'type_id': number;
    'volume' ? : number;
} & {
    [key: string]: any;
};

export type Response_get_universe_types_type_id_404 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_wars_200 = Array < number >
;

export type Response_get_wars_war_id_200 = {
    'aggressor': {
        'alliance_id' ? : number;
        'corporation_id' ? : number;
        'isk_destroyed': number;
        'ships_killed': number;
    } & {
        [key: string]: any;
    };
    'allies' ? : Array < {
            'alliance_id' ? : number;
            'corporation_id' ? : number;
        } & {
            [key: string]: any;
        } >
    ;
    'declared': string;
    'defender': {
        'alliance_id' ? : number;
        'corporation_id' ? : number;
        'isk_destroyed': number;
        'ships_killed': number;
    } & {
        [key: string]: any;
    };
    'finished' ? : string;
    'id': number;
    'mutual': boolean;
    'open_for_allies': boolean;
    'retracted' ? : string;
    'started' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_wars_war_id_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Response_get_wars_war_id_killmails_200 = Array < {
        'killmail_hash': string;
        'killmail_id': number;
    } & {
        [key: string]: any;
    } >
;

export type Response_get_wars_war_id_killmails_422 = {
    'error' ? : string;
} & {
    [key: string]: any;
};

export type Logger = {
    log: (line: string) => any
};

export interface ResponseWithBody < S extends number, T > extends Response {
    status: S;
    body: T;
}

export type QueryParameters = {
    [param: string]: any
};

export interface CommonRequestOptions {
    $queryParameters ? : QueryParameters;
    $domain ? : string;
    $path ? : string | ((path: string) => string);
    $retries ? : number; // number of retries; see: https://github.com/visionmedia/superagent/blob/master/docs/index.md#retrying-requests
    $timeout ? : number; // request timeout in milliseconds; see: https://github.com/visionmedia/superagent/blob/master/docs/index.md#timeouts
    $deadline ? : number; // request deadline in milliseconds; see: https://github.com/visionmedia/superagent/blob/master/docs/index.md#timeouts
}

/**
 * An OpenAPI for EVE Online
 * @class Esi
 * @param {(string)} [domainOrOptions] - The project domain.
 */
export class Esi {

    private domain: string = "https://esi.evetech.net/latest";
    private errorHandlers: CallbackHandler[] = [];
    private requestHeadersHandler ? : RequestHeadersHandler;
    private configureAgentHandler ? : ConfigureAgentHandler;
    private configureRequestHandler ? : ConfigureRequestHandler;

    constructor(domain ? : string, private logger ? : Logger) {
        if (domain) {
            this.domain = domain;
        }
    }

    getDomain() {
        return this.domain;
    }

    addErrorHandler(handler: CallbackHandler) {
        this.errorHandlers.push(handler);
    }

    setRequestHeadersHandler(handler: RequestHeadersHandler) {
        this.requestHeadersHandler = handler;
    }

    setConfigureAgentHandler(handler: ConfigureAgentHandler) {
        this.configureAgentHandler = handler;
    }

    setConfigureRequestHandler(handler: ConfigureRequestHandler) {
        this.configureRequestHandler = handler;
    }

    private request(method: string, url: string, body: any, headers: RequestHeaders, queryParameters: QueryParameters, form: any, reject: CallbackHandler, resolve: CallbackHandler, opts: CommonRequestOptions) {
        if (this.logger) {
            this.logger.log(`Call ${method} ${url}`);
        }

        const agent = this.configureAgentHandler ?
            this.configureAgentHandler(request.default) :
            request.default;

        let req = agent(method, url);
        if (this.configureRequestHandler) {
            req = this.configureRequestHandler(req);
        }

        req = req.query(queryParameters);

        if (body) {
            req.send(body);

            if (typeof(body) === 'object' && !(body.constructor.name === 'Buffer')) {
                headers['Content-Type'] = 'application/json';
            }
        }

        if (Object.keys(form).length > 0) {
            req.type('form');
            req.send(form);
        }

        if (this.requestHeadersHandler) {
            headers = this.requestHeadersHandler({
                ...headers
            });
        }

        req.set(headers);

        if (opts.$retries && opts.$retries > 0) {
            req.retry(opts.$retries);
        }

        if (opts.$timeout && opts.$timeout > 0 || opts.$deadline && opts.$deadline > 0) {
            req.timeout({
                deadline: opts.$deadline,
                response: opts.$timeout
            });
        }

        req.end((error, response) => {
            // an error will also be emitted for a 4xx and 5xx status code
            // the error object will then have error.status and error.response fields
            // see superagent error handling: https://github.com/visionmedia/superagent/blob/master/docs/index.md#error-handling
            if (error) {
                reject(error);
                this.errorHandlers.forEach(handler => handler(error));
            } else {
                resolve(response);
            }
        });
    }

    private convertParameterCollectionFormat < T > (param: T, collectionFormat: string | undefined): T | string {
        if (Array.isArray(param) && param.length >= 2) {
            switch (collectionFormat) {
                case "csv":
                    return param.join(",");
                case "ssv":
                    return param.join(" ");
                case "tsv":
                    return param.join("\t");
                case "pipes":
                    return param.join("|");
                default:
                    return param;
            }
        }

        return param;
    }

    get_alliancesURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List all active player alliances

---
Alternate route: `/legacy/alliances/`

Alternate route: `/v1/alliances/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_alliances

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_alliances(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_alliances_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_alliances_alliance_idURL(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{alliance_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['allianceId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Public information about an alliance

---
Alternate route: `/v3/alliances/{alliance_id}/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_alliances_alliance_id
         * @param {integer} allianceId - An EVE alliance ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_alliances_alliance_id(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_alliances_alliance_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_alliances_alliance_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{alliance_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['allianceId'],
                    ''
                ).toString())}`
            );

            if (parameters['allianceId'] === undefined) {
                reject(new Error('Missing required  parameter: allianceId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_alliances_alliance_id_contactsURL(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{alliance_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['allianceId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return contacts of an alliance

---
Alternate route: `/dev/alliances/{alliance_id}/contacts/`

Alternate route: `/v2/alliances/{alliance_id}/contacts/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_alliances_alliance_id_contacts
         * @param {integer} allianceId - An EVE alliance ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_alliances_alliance_id_contacts(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_alliances_alliance_id_contacts_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{alliance_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['allianceId'],
                    ''
                ).toString())}`
            );

            if (parameters['allianceId'] === undefined) {
                reject(new Error('Missing required  parameter: allianceId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_alliances_alliance_id_contacts_labelsURL(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/contacts/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{alliance_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['allianceId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return custom labels for an alliance's contacts

---
Alternate route: `/dev/alliances/{alliance_id}/contacts/labels/`

Alternate route: `/legacy/alliances/{alliance_id}/contacts/labels/`

Alternate route: `/v1/alliances/{alliance_id}/contacts/labels/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_alliances_alliance_id_contacts_labels
         * @param {integer} allianceId - An EVE alliance ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_alliances_alliance_id_contacts_labels(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_alliances_alliance_id_contacts_labels_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/contacts/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{alliance_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['allianceId'],
                    ''
                ).toString())}`
            );

            if (parameters['allianceId'] === undefined) {
                reject(new Error('Missing required  parameter: allianceId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_alliances_alliance_id_corporationsURL(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/corporations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{alliance_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['allianceId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List all current member corporations of an alliance

---
Alternate route: `/legacy/alliances/{alliance_id}/corporations/`

Alternate route: `/v1/alliances/{alliance_id}/corporations/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_alliances_alliance_id_corporations
         * @param {integer} allianceId - An EVE alliance ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_alliances_alliance_id_corporations(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_alliances_alliance_id_corporations_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/corporations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{alliance_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['allianceId'],
                    ''
                ).toString())}`
            );

            if (parameters['allianceId'] === undefined) {
                reject(new Error('Missing required  parameter: allianceId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_alliances_alliance_id_iconsURL(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/icons/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{alliance_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['allianceId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get the icon urls for a alliance

---
Alternate route: `/legacy/alliances/{alliance_id}/icons/`

Alternate route: `/v1/alliances/{alliance_id}/icons/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_alliances_alliance_id_icons
         * @param {integer} allianceId - An EVE alliance ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_alliances_alliance_id_icons(parameters: {
        'allianceId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_alliances_alliance_id_icons_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_alliances_alliance_id_icons_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/alliances/{alliance_id}/icons/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{alliance_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['allianceId'],
                    ''
                ).toString())}`
            );

            if (parameters['allianceId'] === undefined) {
                reject(new Error('Missing required  parameter: allianceId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_affiliationURL(parameters: {
        'characters': Array < number >
            ,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/affiliation/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Bulk lookup of character IDs to corporation, alliance and faction

---
Alternate route: `/dev/characters/affiliation/`

Alternate route: `/legacy/characters/affiliation/`

Alternate route: `/v1/characters/affiliation/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#post_characters_affiliation
         * @param {} characters - The character IDs to fetch affiliations for. All characters must exist, or none will be returned

    */
    post_characters_affiliation(parameters: {
        'characters': Array < number >
            ,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_post_characters_affiliation_200 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_post_characters_affiliation_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/affiliation/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['characters'] !== undefined) {
                body = parameters['characters'];
            }

            if (parameters['characters'] === undefined) {
                reject(new Error('Missing required  parameter: characters'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_idURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Public information about a character

---
Alternate route: `/dev/characters/{character_id}/`

Alternate route: `/v4/characters/{character_id}/`

---
This route is cached for up to 86400 seconds
    * @method
    * @name Esi#get_characters_character_id
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_characters_character_id(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_characters_character_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_agents_researchURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/agents_research/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of agents research information for a character. The formula for finding the current research points with an agent is: currentPoints = remainderPoints + pointsPerDay * days(currentTime - researchStartDate)

---
Alternate route: `/dev/characters/{character_id}/agents_research/`

Alternate route: `/legacy/characters/{character_id}/agents_research/`

Alternate route: `/v1/characters/{character_id}/agents_research/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_agents_research
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_agents_research(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_agents_research_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/agents_research/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_assetsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/assets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of the characters assets

---
Alternate route: `/dev/characters/{character_id}/assets/`

Alternate route: `/v4/characters/{character_id}/assets/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_assets
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_assets(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_assets_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/assets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_character_id_assets_locationsURL(parameters: {
        'characterId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/assets/locations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return locations for a set of item ids, which you can get from character assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)

---
Alternate route: `/dev/characters/{character_id}/assets/locations/`

Alternate route: `/v2/characters/{character_id}/assets/locations/`

    * @method
    * @name Esi#post_characters_character_id_assets_locations
         * @param {integer} characterId - An EVE character ID

         * @param {} itemIds - A list of item ids
         * @param {string} token - Access token to use if unable to set a header
    */
    post_characters_character_id_assets_locations(parameters: {
        'characterId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_post_characters_character_id_assets_locations_200 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/assets/locations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['itemIds'] !== undefined) {
                body = parameters['itemIds'];
            }

            if (parameters['itemIds'] === undefined) {
                reject(new Error('Missing required  parameter: itemIds'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_character_id_assets_namesURL(parameters: {
        'characterId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/assets/names/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return names for a set of item ids, which you can get from character assets endpoint. Typically used for items that can customize names, like containers or ships.

---
Alternate route: `/dev/characters/{character_id}/assets/names/`

Alternate route: `/legacy/characters/{character_id}/assets/names/`

Alternate route: `/v1/characters/{character_id}/assets/names/`

    * @method
    * @name Esi#post_characters_character_id_assets_names
         * @param {integer} characterId - An EVE character ID

         * @param {} itemIds - A list of item ids
         * @param {string} token - Access token to use if unable to set a header
    */
    post_characters_character_id_assets_names(parameters: {
        'characterId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_post_characters_character_id_assets_names_200 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/assets/names/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['itemIds'] !== undefined) {
                body = parameters['itemIds'];
            }

            if (parameters['itemIds'] === undefined) {
                reject(new Error('Missing required  parameter: itemIds'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_attributesURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/attributes/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return attributes of a character

---
Alternate route: `/dev/characters/{character_id}/attributes/`

Alternate route: `/legacy/characters/{character_id}/attributes/`

Alternate route: `/v1/characters/{character_id}/attributes/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_characters_character_id_attributes
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_attributes(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_attributes_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/attributes/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_blueprintsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/blueprints/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of blueprints the character owns

---
Alternate route: `/dev/characters/{character_id}/blueprints/`

Alternate route: `/v2/characters/{character_id}/blueprints/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_blueprints
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_blueprints(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_blueprints_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/blueprints/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_bookmarksURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/bookmarks/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * A list of your character's personal bookmarks

---
Alternate route: `/dev/characters/{character_id}/bookmarks/`

Alternate route: `/v2/characters/{character_id}/bookmarks/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_bookmarks
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_bookmarks(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_bookmarks_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/bookmarks/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_bookmarks_foldersURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/bookmarks/folders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * A list of your character's personal bookmark folders

---
Alternate route: `/dev/characters/{character_id}/bookmarks/folders/`

Alternate route: `/v2/characters/{character_id}/bookmarks/folders/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_bookmarks_folders
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_bookmarks_folders(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_bookmarks_folders_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/bookmarks/folders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_calendarURL(parameters: {
        'characterId': number,
        'fromEvent' ? : number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['fromEvent'] !== undefined) {
            queryParameters['from_event'] = this.convertParameterCollectionFormat(
                parameters['fromEvent'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get 50 event summaries from the calendar. If no from_event ID is given, the resource will return the next 50 chronological event summaries from now. If a from_event ID is specified, it will return the next 50 chronological event summaries from after that event

---
Alternate route: `/legacy/characters/{character_id}/calendar/`

Alternate route: `/v1/characters/{character_id}/calendar/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_characters_character_id_calendar
         * @param {integer} characterId - An EVE character ID

         * @param {integer} fromEvent - The event ID to retrieve events from
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_calendar(parameters: {
        'characterId': number,
        'fromEvent' ? : number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_calendar_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['fromEvent'] !== undefined) {
                queryParameters['from_event'] = this.convertParameterCollectionFormat(
                    parameters['fromEvent'],
                    ''
                );
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_calendar_event_idURL(parameters: {
        'characterId': number,
        'eventId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/{event_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{event_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['eventId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get all the information for a specific event

---
Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_characters_character_id_calendar_event_id
         * @param {integer} characterId - An EVE character ID

         * @param {integer} eventId - The id of the event requested
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_calendar_event_id(parameters: {
        'characterId': number,
        'eventId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_calendar_event_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_characters_character_id_calendar_event_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/{event_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{event_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['eventId'],
                    ''
                ).toString())}`
            );

            if (parameters['eventId'] === undefined) {
                reject(new Error('Missing required  parameter: eventId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    put_characters_character_id_calendar_event_idURL(parameters: {
        'characterId': number,
        'eventId': number,
        'response': {
            'response': "accepted" | "declined" | "tentative";
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/{event_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{event_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['eventId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Set your response status to an event

---
Alternate route: `/v3/characters/{character_id}/calendar/{event_id}/`


---
[Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#PUT-/characters/{character_id}/calendar/{event_id}/)
    * @method
    * @name Esi#put_characters_character_id_calendar_event_id
         * @param {integer} characterId - An EVE character ID

         * @param {integer} eventId - The ID of the event requested
         * @param {} response - The response value to set, overriding current value
         * @param {string} token - Access token to use if unable to set a header
    */
    put_characters_character_id_calendar_event_id(parameters: {
        'characterId': number,
        'eventId': number,
        'response': {
            'response': "accepted" | "declined" | "tentative";
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/{event_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{event_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['eventId'],
                    ''
                ).toString())}`
            );

            if (parameters['eventId'] === undefined) {
                reject(new Error('Missing required  parameter: eventId'));
                return;
            }

            if (parameters['response'] !== undefined) {
                body = parameters['response'];
            }

            if (parameters['response'] === undefined) {
                reject(new Error('Missing required  parameter: response'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_calendar_event_id_attendeesURL(parameters: {
        'characterId': number,
        'eventId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/{event_id}/attendees/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{event_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['eventId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get all invited attendees for a given event

---
Alternate route: `/legacy/characters/{character_id}/calendar/{event_id}/attendees/`

Alternate route: `/v1/characters/{character_id}/calendar/{event_id}/attendees/`

---
This route is cached for up to 600 seconds
    * @method
    * @name Esi#get_characters_character_id_calendar_event_id_attendees
         * @param {integer} characterId - An EVE character ID

         * @param {integer} eventId - The id of the event requested
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_calendar_event_id_attendees(parameters: {
        'characterId': number,
        'eventId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_calendar_event_id_attendees_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_characters_character_id_calendar_event_id_attendees_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/calendar/{event_id}/attendees/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{event_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['eventId'],
                    ''
                ).toString())}`
            );

            if (parameters['eventId'] === undefined) {
                reject(new Error('Missing required  parameter: eventId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_clonesURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/clones/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * A list of the character's clones

---
Alternate route: `/v3/characters/{character_id}/clones/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_characters_character_id_clones
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_clones(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_clones_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/clones/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    delete_characters_character_id_contactsURL(parameters: {
        'characterId': number,
        'contactIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        if (parameters['contactIds'] !== undefined) {
            queryParameters['contact_ids'] = this.convertParameterCollectionFormat(
                parameters['contactIds'],
                ''
            );
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Bulk delete contacts

---
Alternate route: `/dev/characters/{character_id}/contacts/`

Alternate route: `/v2/characters/{character_id}/contacts/`

    * @method
    * @name Esi#delete_characters_character_id_contacts
         * @param {integer} characterId - An EVE character ID
         * @param {array} contactIds - A list of contacts to delete

         * @param {string} token - Access token to use if unable to set a header
    */
    delete_characters_character_id_contacts(parameters: {
        'characterId': number,
        'contactIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            if (parameters['contactIds'] !== undefined) {
                queryParameters['contact_ids'] = this.convertParameterCollectionFormat(
                    parameters['contactIds'],
                    ''
                );
            }

            if (parameters['contactIds'] === undefined) {
                reject(new Error('Missing required  parameter: contactIds'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_contactsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return contacts of a character

---
Alternate route: `/dev/characters/{character_id}/contacts/`

Alternate route: `/v2/characters/{character_id}/contacts/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_contacts
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_contacts(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_contacts_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_character_id_contactsURL(parameters: {
        'characterId': number,
        'contactIds': Array < number >
            ,
        'labelIds' ? : Array < number >
            ,
        'standing': number,
        'token' ? : string,
        'watched' ? : boolean,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );

        queryParameters['datasource'] = 'tranquility';

        if (parameters['labelIds'] !== undefined) {
            queryParameters['label_ids'] = this.convertParameterCollectionFormat(
                parameters['labelIds'],
                ''
            );
        }

        if (parameters['standing'] !== undefined) {
            queryParameters['standing'] = this.convertParameterCollectionFormat(
                parameters['standing'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters['watched'] !== undefined) {
            queryParameters['watched'] = this.convertParameterCollectionFormat(
                parameters['watched'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Bulk add contacts with same settings

---
Alternate route: `/dev/characters/{character_id}/contacts/`

Alternate route: `/v2/characters/{character_id}/contacts/`

    * @method
    * @name Esi#post_characters_character_id_contacts
         * @param {integer} characterId - An EVE character ID
         * @param {} contactIds - A list of contacts

         * @param {array} labelIds - Add custom labels to the new contact
         * @param {number} standing - Standing for the contact
         * @param {string} token - Access token to use if unable to set a header
         * @param {boolean} watched - Whether the contact should be watched, note this is only effective on characters
    */
    post_characters_character_id_contacts(parameters: {
        'characterId': number,
        'contactIds': Array < number >
            ,
        'labelIds' ? : Array < number >
            ,
        'standing': number,
        'token' ? : string,
        'watched' ? : boolean,
    } & CommonRequestOptions): Promise < ResponseWithBody < 201, Response_post_characters_character_id_contacts_201 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout > | ResponseWithBody < 520, Response_post_characters_character_id_contacts_520 >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            if (parameters['contactIds'] !== undefined) {
                body = parameters['contactIds'];
            }

            if (parameters['contactIds'] === undefined) {
                reject(new Error('Missing required  parameter: contactIds'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['labelIds'] !== undefined) {
                queryParameters['label_ids'] = this.convertParameterCollectionFormat(
                    parameters['labelIds'],
                    ''
                );
            }

            if (parameters['standing'] !== undefined) {
                queryParameters['standing'] = this.convertParameterCollectionFormat(
                    parameters['standing'],
                    ''
                );
            }

            if (parameters['standing'] === undefined) {
                reject(new Error('Missing required  parameter: standing'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters['watched'] !== undefined) {
                queryParameters['watched'] = this.convertParameterCollectionFormat(
                    parameters['watched'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    put_characters_character_id_contactsURL(parameters: {
        'characterId': number,
        'contactIds': Array < number >
            ,
        'labelIds' ? : Array < number >
            ,
        'standing': number,
        'token' ? : string,
        'watched' ? : boolean,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );

        queryParameters['datasource'] = 'tranquility';

        if (parameters['labelIds'] !== undefined) {
            queryParameters['label_ids'] = this.convertParameterCollectionFormat(
                parameters['labelIds'],
                ''
            );
        }

        if (parameters['standing'] !== undefined) {
            queryParameters['standing'] = this.convertParameterCollectionFormat(
                parameters['standing'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters['watched'] !== undefined) {
            queryParameters['watched'] = this.convertParameterCollectionFormat(
                parameters['watched'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Bulk edit contacts with same settings

---
Alternate route: `/dev/characters/{character_id}/contacts/`

Alternate route: `/v2/characters/{character_id}/contacts/`

    * @method
    * @name Esi#put_characters_character_id_contacts
         * @param {integer} characterId - An EVE character ID
         * @param {} contactIds - A list of contacts

         * @param {array} labelIds - Add custom labels to the contact
         * @param {number} standing - Standing for the contact
         * @param {string} token - Access token to use if unable to set a header
         * @param {boolean} watched - Whether the contact should be watched, note this is only effective on characters
    */
    put_characters_character_id_contacts(parameters: {
        'characterId': number,
        'contactIds': Array < number >
            ,
        'labelIds' ? : Array < number >
            ,
        'standing': number,
        'token' ? : string,
        'watched' ? : boolean,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            if (parameters['contactIds'] !== undefined) {
                body = parameters['contactIds'];
            }

            if (parameters['contactIds'] === undefined) {
                reject(new Error('Missing required  parameter: contactIds'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['labelIds'] !== undefined) {
                queryParameters['label_ids'] = this.convertParameterCollectionFormat(
                    parameters['labelIds'],
                    ''
                );
            }

            if (parameters['standing'] !== undefined) {
                queryParameters['standing'] = this.convertParameterCollectionFormat(
                    parameters['standing'],
                    ''
                );
            }

            if (parameters['standing'] === undefined) {
                reject(new Error('Missing required  parameter: standing'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters['watched'] !== undefined) {
                queryParameters['watched'] = this.convertParameterCollectionFormat(
                    parameters['watched'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_contacts_labelsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return custom labels for a character's contacts

---
Alternate route: `/dev/characters/{character_id}/contacts/labels/`

Alternate route: `/legacy/characters/{character_id}/contacts/labels/`

Alternate route: `/v1/characters/{character_id}/contacts/labels/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_contacts_labels
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_contacts_labels(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_contacts_labels_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contacts/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_contractsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contracts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns contracts available to a character, only if the character is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is "in_progress".

---
Alternate route: `/dev/characters/{character_id}/contracts/`

Alternate route: `/legacy/characters/{character_id}/contracts/`

Alternate route: `/v1/characters/{character_id}/contracts/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_contracts
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_contracts(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_contracts_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contracts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_contracts_contract_id_bidsURL(parameters: {
        'characterId': number,
        'contractId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contracts/{contract_id}/bids/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{contract_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['contractId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Lists bids on a particular auction contract

---
Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/bids/`

Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/bids/`

Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/bids/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_contracts_contract_id_bids
         * @param {integer} characterId - An EVE character ID
         * @param {integer} contractId - ID of a contract

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_contracts_contract_id_bids(parameters: {
        'characterId': number,
        'contractId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_contracts_contract_id_bids_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_characters_character_id_contracts_contract_id_bids_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contracts/{contract_id}/bids/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            path = path.replace(
                '{contract_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['contractId'],
                    ''
                ).toString())}`
            );

            if (parameters['contractId'] === undefined) {
                reject(new Error('Missing required  parameter: contractId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_contracts_contract_id_itemsURL(parameters: {
        'characterId': number,
        'contractId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contracts/{contract_id}/items/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{contract_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['contractId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Lists items of a particular contract

---
Alternate route: `/dev/characters/{character_id}/contracts/{contract_id}/items/`

Alternate route: `/legacy/characters/{character_id}/contracts/{contract_id}/items/`

Alternate route: `/v1/characters/{character_id}/contracts/{contract_id}/items/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_contracts_contract_id_items
         * @param {integer} characterId - An EVE character ID
         * @param {integer} contractId - ID of a contract

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_contracts_contract_id_items(parameters: {
        'characterId': number,
        'contractId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_contracts_contract_id_items_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_characters_character_id_contracts_contract_id_items_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/contracts/{contract_id}/items/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            path = path.replace(
                '{contract_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['contractId'],
                    ''
                ).toString())}`
            );

            if (parameters['contractId'] === undefined) {
                reject(new Error('Missing required  parameter: contractId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_corporationhistoryURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/corporationhistory/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of all the corporations a character has been a member of

---
Alternate route: `/dev/characters/{character_id}/corporationhistory/`

Alternate route: `/legacy/characters/{character_id}/corporationhistory/`

Alternate route: `/v1/characters/{character_id}/corporationhistory/`

---
This route is cached for up to 86400 seconds
    * @method
    * @name Esi#get_characters_character_id_corporationhistory
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_characters_character_id_corporationhistory(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_corporationhistory_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/corporationhistory/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_character_id_cspaURL(parameters: {
        'characterId': number,
        'characters': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/cspa/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );

        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Takes a source character ID in the url and a set of target character ID's in the body, returns a CSPA charge cost

---
Alternate route: `/dev/characters/{character_id}/cspa/`

Alternate route: `/v4/characters/{character_id}/cspa/`

    * @method
    * @name Esi#post_characters_character_id_cspa
         * @param {integer} characterId - An EVE character ID
         * @param {} characters - The target characters to calculate the charge for

         * @param {string} token - Access token to use if unable to set a header
    */
    post_characters_character_id_cspa(parameters: {
        'characterId': number,
        'characters': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 201, Response_post_characters_character_id_cspa_201 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/cspa/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            if (parameters['characters'] !== undefined) {
                body = parameters['characters'];
            }

            if (parameters['characters'] === undefined) {
                reject(new Error('Missing required  parameter: characters'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_fatigueURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fatigue/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a character's jump activation and fatigue information

---
Alternate route: `/dev/characters/{character_id}/fatigue/`

Alternate route: `/legacy/characters/{character_id}/fatigue/`

Alternate route: `/v1/characters/{character_id}/fatigue/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_fatigue
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_fatigue(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_fatigue_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fatigue/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_fittingsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fittings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return fittings of a character

---
Alternate route: `/dev/characters/{character_id}/fittings/`

Alternate route: `/v2/characters/{character_id}/fittings/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_fittings
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_fittings(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_fittings_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fittings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_character_id_fittingsURL(parameters: {
        'characterId': number,
        'fitting': {
            'description': string;
            'items': Array < {
                    'flag': "Cargo" | "DroneBay" | "FighterBay" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "Invalid" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "ServiceSlot0" | "ServiceSlot1" | "ServiceSlot2" | "ServiceSlot3" | "ServiceSlot4" | "ServiceSlot5" | "ServiceSlot6" | "ServiceSlot7" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3";
                    'quantity': number;
                    'type_id': number;
                } & {
                    [key: string]: any;
                } >
            ;
            'name': string;
            'ship_type_id': number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fittings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Save a new fitting for a character

---
Alternate route: `/dev/characters/{character_id}/fittings/`

Alternate route: `/v2/characters/{character_id}/fittings/`

    * @method
    * @name Esi#post_characters_character_id_fittings
         * @param {integer} characterId - An EVE character ID

         * @param {} fitting - Details about the new fitting
         * @param {string} token - Access token to use if unable to set a header
    */
    post_characters_character_id_fittings(parameters: {
        'characterId': number,
        'fitting': {
            'description': string;
            'items': Array < {
                    'flag': "Cargo" | "DroneBay" | "FighterBay" | "HiSlot0" | "HiSlot1" | "HiSlot2" | "HiSlot3" | "HiSlot4" | "HiSlot5" | "HiSlot6" | "HiSlot7" | "Invalid" | "LoSlot0" | "LoSlot1" | "LoSlot2" | "LoSlot3" | "LoSlot4" | "LoSlot5" | "LoSlot6" | "LoSlot7" | "MedSlot0" | "MedSlot1" | "MedSlot2" | "MedSlot3" | "MedSlot4" | "MedSlot5" | "MedSlot6" | "MedSlot7" | "RigSlot0" | "RigSlot1" | "RigSlot2" | "ServiceSlot0" | "ServiceSlot1" | "ServiceSlot2" | "ServiceSlot3" | "ServiceSlot4" | "ServiceSlot5" | "ServiceSlot6" | "ServiceSlot7" | "SubSystemSlot0" | "SubSystemSlot1" | "SubSystemSlot2" | "SubSystemSlot3";
                    'quantity': number;
                    'type_id': number;
                } & {
                    [key: string]: any;
                } >
            ;
            'name': string;
            'ship_type_id': number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 201, Response_post_characters_character_id_fittings_201 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fittings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['fitting'] !== undefined) {
                body = parameters['fitting'];
            }

            if (parameters['fitting'] === undefined) {
                reject(new Error('Missing required  parameter: fitting'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    delete_characters_character_id_fittings_fitting_idURL(parameters: {
        'characterId': number,
        'fittingId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fittings/{fitting_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fitting_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fittingId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Delete a fitting from a character

---
Alternate route: `/dev/characters/{character_id}/fittings/{fitting_id}/`

Alternate route: `/legacy/characters/{character_id}/fittings/{fitting_id}/`

Alternate route: `/v1/characters/{character_id}/fittings/{fitting_id}/`

    * @method
    * @name Esi#delete_characters_character_id_fittings_fitting_id
         * @param {integer} characterId - An EVE character ID

         * @param {integer} fittingId - ID for a fitting of this character
         * @param {string} token - Access token to use if unable to set a header
    */
    delete_characters_character_id_fittings_fitting_id(parameters: {
        'characterId': number,
        'fittingId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fittings/{fitting_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fitting_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fittingId'],
                    ''
                ).toString())}`
            );

            if (parameters['fittingId'] === undefined) {
                reject(new Error('Missing required  parameter: fittingId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_fleetURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fleet/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return the fleet ID the character is in, if any.

---
Alternate route: `/legacy/characters/{character_id}/fleet/`

Alternate route: `/v1/characters/{character_id}/fleet/`

---
This route is cached for up to 60 seconds

---
Warning: This route has an upgrade available

---
[Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/characters/{character_id}/fleet/)
    * @method
    * @name Esi#get_characters_character_id_fleet
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_fleet(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_fleet_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_characters_character_id_fleet_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fleet/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_fw_statsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fw/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Statistical overview of a character involved in faction warfare

---
Alternate route: `/legacy/characters/{character_id}/fw/stats/`

Alternate route: `/v1/characters/{character_id}/fw/stats/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_characters_character_id_fw_stats
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_fw_stats(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_fw_stats_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/fw/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_implantsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/implants/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return implants on the active clone of a character

---
Alternate route: `/legacy/characters/{character_id}/implants/`

Alternate route: `/v1/characters/{character_id}/implants/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_characters_character_id_implants
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_implants(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_implants_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/implants/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_industry_jobsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'includeCompleted' ? : boolean,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/industry/jobs/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['includeCompleted'] !== undefined) {
            queryParameters['include_completed'] = this.convertParameterCollectionFormat(
                parameters['includeCompleted'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List industry jobs placed by a character

---
Alternate route: `/dev/characters/{character_id}/industry/jobs/`

Alternate route: `/legacy/characters/{character_id}/industry/jobs/`

Alternate route: `/v1/characters/{character_id}/industry/jobs/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_industry_jobs
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} includeCompleted - Whether to retrieve completed character industry jobs. Only includes jobs from the past 90 days
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_industry_jobs(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'includeCompleted' ? : boolean,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_industry_jobs_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/industry/jobs/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['includeCompleted'] !== undefined) {
                queryParameters['include_completed'] = this.convertParameterCollectionFormat(
                    parameters['includeCompleted'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_killmails_recentURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/killmails/recent/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of a character's kills and losses going back 90 days

---
Alternate route: `/dev/characters/{character_id}/killmails/recent/`

Alternate route: `/legacy/characters/{character_id}/killmails/recent/`

Alternate route: `/v1/characters/{character_id}/killmails/recent/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_characters_character_id_killmails_recent
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_killmails_recent(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_killmails_recent_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/killmails/recent/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_locationURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/location/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Information about the characters current location. Returns the current solar system id, and also the current station or structure ID if applicable

---
Alternate route: `/legacy/characters/{character_id}/location/`

Alternate route: `/v1/characters/{character_id}/location/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_characters_character_id_location
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_location(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_location_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/location/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_loyalty_pointsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/loyalty/points/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of loyalty points for all corporations the character has worked for

---
Alternate route: `/dev/characters/{character_id}/loyalty/points/`

Alternate route: `/legacy/characters/{character_id}/loyalty/points/`

Alternate route: `/v1/characters/{character_id}/loyalty/points/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_loyalty_points
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_loyalty_points(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_loyalty_points_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/loyalty/points/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_mailURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'labels' ? : Array < number >
            ,
        'lastMailId' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['labels'] !== undefined) {
            queryParameters['labels'] = this.convertParameterCollectionFormat(
                parameters['labels'],
                ''
            );
        }

        if (parameters['lastMailId'] !== undefined) {
            queryParameters['last_mail_id'] = this.convertParameterCollectionFormat(
                parameters['lastMailId'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return the 50 most recent mail headers belonging to the character that match the query criteria. Queries can be filtered by label, and last_mail_id can be used to paginate backwards

---
Alternate route: `/dev/characters/{character_id}/mail/`

Alternate route: `/legacy/characters/{character_id}/mail/`

Alternate route: `/v1/characters/{character_id}/mail/`

---
This route is cached for up to 30 seconds
    * @method
    * @name Esi#get_characters_character_id_mail
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {array} labels - Fetch only mails that match one or more of the given labels
         * @param {integer} lastMailId - List only mail with an ID lower than the given ID, if present
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_mail(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'labels' ? : Array < number >
            ,
        'lastMailId' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_mail_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['labels'] !== undefined) {
                queryParameters['labels'] = this.convertParameterCollectionFormat(
                    parameters['labels'],
                    ''
                );
            }

            if (parameters['lastMailId'] !== undefined) {
                queryParameters['last_mail_id'] = this.convertParameterCollectionFormat(
                    parameters['lastMailId'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_character_id_mailURL(parameters: {
        'characterId': number,
        'mail': {
            'approved_cost' ? : number;
            'body': string;
            'recipients': Array < {
                    'recipient_id': number;
                    'recipient_type': "alliance" | "character" | "corporation" | "mailing_list";
                } & {
                    [key: string]: any;
                } >
            ;
            'subject': string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Create and send a new mail

---
Alternate route: `/dev/characters/{character_id}/mail/`

Alternate route: `/legacy/characters/{character_id}/mail/`

Alternate route: `/v1/characters/{character_id}/mail/`

    * @method
    * @name Esi#post_characters_character_id_mail
         * @param {integer} characterId - An EVE character ID

         * @param {} mail - The mail to send
         * @param {string} token - Access token to use if unable to set a header
    */
    post_characters_character_id_mail(parameters: {
        'characterId': number,
        'mail': {
            'approved_cost' ? : number;
            'body': string;
            'recipients': Array < {
                    'recipient_id': number;
                    'recipient_type': "alliance" | "character" | "corporation" | "mailing_list";
                } & {
                    [key: string]: any;
                } >
            ;
            'subject': string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 201, Response_post_characters_character_id_mail_201 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout > | ResponseWithBody < 520, Response_post_characters_character_id_mail_520 >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['mail'] !== undefined) {
                body = parameters['mail'];
            }

            if (parameters['mail'] === undefined) {
                reject(new Error('Missing required  parameter: mail'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_mail_labelsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of the users mail labels, unread counts for each label and a total unread count.

---
Alternate route: `/dev/characters/{character_id}/mail/labels/`

Alternate route: `/v3/characters/{character_id}/mail/labels/`

---
This route is cached for up to 30 seconds
    * @method
    * @name Esi#get_characters_character_id_mail_labels
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_mail_labels(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_mail_labels_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_characters_character_id_mail_labelsURL(parameters: {
        'characterId': number,
        'label': {
            'color' ? : "#0000fe" | "#006634" | "#0099ff" | "#00ff33" | "#01ffff" | "#349800" | "#660066" | "#666666" | "#999999" | "#99ffff" | "#9a0000" | "#ccff9a" | "#e6e6e6" | "#fe0000" | "#ff6600" | "#ffff01" | "#ffffcd" | "#ffffff";
            'name': string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Create a mail label

---
Alternate route: `/dev/characters/{character_id}/mail/labels/`

Alternate route: `/legacy/characters/{character_id}/mail/labels/`

Alternate route: `/v2/characters/{character_id}/mail/labels/`

    * @method
    * @name Esi#post_characters_character_id_mail_labels
         * @param {integer} characterId - An EVE character ID

         * @param {} label - Label to create
         * @param {string} token - Access token to use if unable to set a header
    */
    post_characters_character_id_mail_labels(parameters: {
        'characterId': number,
        'label': {
            'color' ? : "#0000fe" | "#006634" | "#0099ff" | "#00ff33" | "#01ffff" | "#349800" | "#660066" | "#666666" | "#999999" | "#99ffff" | "#9a0000" | "#ccff9a" | "#e6e6e6" | "#fe0000" | "#ff6600" | "#ffff01" | "#ffffcd" | "#ffffff";
            'name': string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 201, Response_post_characters_character_id_mail_labels_201 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['label'] !== undefined) {
                body = parameters['label'];
            }

            if (parameters['label'] === undefined) {
                reject(new Error('Missing required  parameter: label'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    delete_characters_character_id_mail_labels_label_idURL(parameters: {
        'characterId': number,
        'labelId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/labels/{label_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{label_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['labelId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Delete a mail label

---
Alternate route: `/dev/characters/{character_id}/mail/labels/{label_id}/`

Alternate route: `/legacy/characters/{character_id}/mail/labels/{label_id}/`

Alternate route: `/v1/characters/{character_id}/mail/labels/{label_id}/`

    * @method
    * @name Esi#delete_characters_character_id_mail_labels_label_id
         * @param {integer} characterId - An EVE character ID

         * @param {integer} labelId - An EVE label id
         * @param {string} token - Access token to use if unable to set a header
    */
    delete_characters_character_id_mail_labels_label_id(parameters: {
        'characterId': number,
        'labelId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_delete_characters_character_id_mail_labels_label_id_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/labels/{label_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{label_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['labelId'],
                    ''
                ).toString())}`
            );

            if (parameters['labelId'] === undefined) {
                reject(new Error('Missing required  parameter: labelId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_mail_listsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/lists/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return all mailing lists that the character is subscribed to

---
Alternate route: `/dev/characters/{character_id}/mail/lists/`

Alternate route: `/legacy/characters/{character_id}/mail/lists/`

Alternate route: `/v1/characters/{character_id}/mail/lists/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_characters_character_id_mail_lists
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_mail_lists(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_mail_lists_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/lists/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    delete_characters_character_id_mail_mail_idURL(parameters: {
        'characterId': number,
        'mailId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/{mail_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{mail_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['mailId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Delete a mail

---
Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`

Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`

Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`

    * @method
    * @name Esi#delete_characters_character_id_mail_mail_id
         * @param {integer} characterId - An EVE character ID

         * @param {integer} mailId - An EVE mail ID
         * @param {string} token - Access token to use if unable to set a header
    */
    delete_characters_character_id_mail_mail_id(parameters: {
        'characterId': number,
        'mailId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/{mail_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{mail_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['mailId'],
                    ''
                ).toString())}`
            );

            if (parameters['mailId'] === undefined) {
                reject(new Error('Missing required  parameter: mailId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_mail_mail_idURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'mailId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/{mail_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{mail_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['mailId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return the contents of an EVE mail

---
Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`

Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`

Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`

---
This route is cached for up to 30 seconds
    * @method
    * @name Esi#get_characters_character_id_mail_mail_id
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} mailId - An EVE mail ID
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_mail_mail_id(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'mailId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_mail_mail_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_characters_character_id_mail_mail_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/{mail_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{mail_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['mailId'],
                    ''
                ).toString())}`
            );

            if (parameters['mailId'] === undefined) {
                reject(new Error('Missing required  parameter: mailId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    put_characters_character_id_mail_mail_idURL(parameters: {
        'characterId': number,
        'contents': {
            'labels' ? : Array < number >
            ;
            'read' ? : boolean;
        } & {
            [key: string]: any;
        },
        'mailId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/{mail_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{mail_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['mailId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Update metadata about a mail

---
Alternate route: `/dev/characters/{character_id}/mail/{mail_id}/`

Alternate route: `/legacy/characters/{character_id}/mail/{mail_id}/`

Alternate route: `/v1/characters/{character_id}/mail/{mail_id}/`

    * @method
    * @name Esi#put_characters_character_id_mail_mail_id
         * @param {integer} characterId - An EVE character ID
         * @param {} contents - Data used to update the mail

         * @param {integer} mailId - An EVE mail ID
         * @param {string} token - Access token to use if unable to set a header
    */
    put_characters_character_id_mail_mail_id(parameters: {
        'characterId': number,
        'contents': {
            'labels' ? : Array < number >
            ;
            'read' ? : boolean;
        } & {
            [key: string]: any;
        },
        'mailId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mail/{mail_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            if (parameters['contents'] !== undefined) {
                body = parameters['contents'];
            }

            if (parameters['contents'] === undefined) {
                reject(new Error('Missing required  parameter: contents'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{mail_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['mailId'],
                    ''
                ).toString())}`
            );

            if (parameters['mailId'] === undefined) {
                reject(new Error('Missing required  parameter: mailId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_medalsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/medals/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of medals the character has

---
Alternate route: `/dev/characters/{character_id}/medals/`

Alternate route: `/legacy/characters/{character_id}/medals/`

Alternate route: `/v1/characters/{character_id}/medals/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_medals
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_medals(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_medals_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/medals/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_miningURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mining/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Paginated record of all mining done by a character for the past 30 days


---
Alternate route: `/dev/characters/{character_id}/mining/`

Alternate route: `/legacy/characters/{character_id}/mining/`

Alternate route: `/v1/characters/{character_id}/mining/`

---
This route is cached for up to 600 seconds
    * @method
    * @name Esi#get_characters_character_id_mining
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_mining(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_mining_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/mining/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_notificationsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/notifications/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return character notifications

---
Alternate route: `/dev/characters/{character_id}/notifications/`

Alternate route: `/v5/characters/{character_id}/notifications/`

---
This route is cached for up to 600 seconds
    * @method
    * @name Esi#get_characters_character_id_notifications
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_notifications(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_notifications_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/notifications/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_notifications_contactsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/notifications/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return notifications about having been added to someone's contact list

---
Alternate route: `/dev/characters/{character_id}/notifications/contacts/`

Alternate route: `/legacy/characters/{character_id}/notifications/contacts/`

Alternate route: `/v1/characters/{character_id}/notifications/contacts/`

---
This route is cached for up to 600 seconds
    * @method
    * @name Esi#get_characters_character_id_notifications_contacts
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_notifications_contacts(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_notifications_contacts_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/notifications/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_onlineURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/online/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Checks if the character is currently online

---
Alternate route: `/v2/characters/{character_id}/online/`

---
This route is cached for up to 60 seconds
    * @method
    * @name Esi#get_characters_character_id_online
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_online(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_online_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/online/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_opportunitiesURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/opportunities/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of tasks finished by a character

---
Alternate route: `/dev/characters/{character_id}/opportunities/`

Alternate route: `/legacy/characters/{character_id}/opportunities/`

Alternate route: `/v1/characters/{character_id}/opportunities/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_opportunities
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_opportunities(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_opportunities_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/opportunities/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_ordersURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/orders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List open market orders placed by a character

---
Alternate route: `/dev/characters/{character_id}/orders/`

Alternate route: `/v2/characters/{character_id}/orders/`

---
This route is cached for up to 1200 seconds
    * @method
    * @name Esi#get_characters_character_id_orders
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_orders(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_orders_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/orders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_orders_historyURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/orders/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List cancelled and expired market orders placed by a character up to 90 days in the past.

---
Alternate route: `/dev/characters/{character_id}/orders/history/`

Alternate route: `/legacy/characters/{character_id}/orders/history/`

Alternate route: `/v1/characters/{character_id}/orders/history/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_orders_history
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_orders_history(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_orders_history_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/orders/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_planetsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/planets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a list of all planetary colonies owned by a character.

---
Alternate route: `/dev/characters/{character_id}/planets/`

Alternate route: `/legacy/characters/{character_id}/planets/`

Alternate route: `/v1/characters/{character_id}/planets/`

---
This route is cached for up to 600 seconds
    * @method
    * @name Esi#get_characters_character_id_planets
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_planets(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_planets_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/planets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_planets_planet_idURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'planetId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/planets/{planet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{planet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['planetId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns full details on the layout of a single planetary colony, including links, pins and routes. Note: Planetary information is only recalculated when the colony is viewed through the client. Information will not update until this criteria is met.

---
Alternate route: `/dev/characters/{character_id}/planets/{planet_id}/`

Alternate route: `/v3/characters/{character_id}/planets/{planet_id}/`

---
This route is cached for up to 600 seconds
    * @method
    * @name Esi#get_characters_character_id_planets_planet_id
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} planetId - Planet id of the target planet
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_planets_planet_id(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'planetId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_planets_planet_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_characters_character_id_planets_planet_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/planets/{planet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{planet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['planetId'],
                    ''
                ).toString())}`
            );

            if (parameters['planetId'] === undefined) {
                reject(new Error('Missing required  parameter: planetId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_portraitURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/portrait/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get portrait urls for a character

---
Alternate route: `/dev/characters/{character_id}/portrait/`

Alternate route: `/v2/characters/{character_id}/portrait/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_characters_character_id_portrait
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_characters_character_id_portrait(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_portrait_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_characters_character_id_portrait_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/portrait/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_rolesURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/roles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a character's corporation roles

---
Alternate route: `/dev/characters/{character_id}/roles/`

Alternate route: `/v2/characters/{character_id}/roles/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_roles
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_roles(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_roles_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/roles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_searchURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'categories': Array < "agent" | "alliance" | "character" | "constellation" | "corporation" | "faction" | "inventory_type" | "region" | "solar_system" | "station" | "structure" >
            ,
        'characterId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'search': string,
        'strict' ? : boolean,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/search/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        if (parameters['categories'] !== undefined) {
            queryParameters['categories'] = this.convertParameterCollectionFormat(
                parameters['categories'],
                ''
            );
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters['search'] !== undefined) {
            queryParameters['search'] = this.convertParameterCollectionFormat(
                parameters['search'],
                ''
            );
        }

        if (parameters['strict'] !== undefined) {
            queryParameters['strict'] = this.convertParameterCollectionFormat(
                parameters['strict'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Search for entities that match a given sub-string.

---
Alternate route: `/dev/characters/{character_id}/search/`

Alternate route: `/legacy/characters/{character_id}/search/`

Alternate route: `/v3/characters/{character_id}/search/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_search
         * @param {string} acceptLanguage - Language to use in the response
         * @param {array} categories - Type of entities to search for
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {string} search - The string to search on
         * @param {boolean} strict - Whether the search should be a strict match
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_search(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'categories': Array < "agent" | "alliance" | "character" | "constellation" | "corporation" | "faction" | "inventory_type" | "region" | "solar_system" | "station" | "structure" >
            ,
        'characterId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'search': string,
        'strict' ? : boolean,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_search_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/search/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            if (parameters['categories'] !== undefined) {
                queryParameters['categories'] = this.convertParameterCollectionFormat(
                    parameters['categories'],
                    ''
                );
            }

            if (parameters['categories'] === undefined) {
                reject(new Error('Missing required  parameter: categories'));
                return;
            }

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters['search'] !== undefined) {
                queryParameters['search'] = this.convertParameterCollectionFormat(
                    parameters['search'],
                    ''
                );
            }

            if (parameters['search'] === undefined) {
                reject(new Error('Missing required  parameter: search'));
                return;
            }

            if (parameters['strict'] !== undefined) {
                queryParameters['strict'] = this.convertParameterCollectionFormat(
                    parameters['strict'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_shipURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/ship/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get the current ship type, name and id

---
Alternate route: `/legacy/characters/{character_id}/ship/`

Alternate route: `/v1/characters/{character_id}/ship/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_characters_character_id_ship
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_ship(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_ship_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/ship/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_skillqueueURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/skillqueue/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List the configured skill queue for the given character

---
Alternate route: `/dev/characters/{character_id}/skillqueue/`

Alternate route: `/legacy/characters/{character_id}/skillqueue/`

Alternate route: `/v2/characters/{character_id}/skillqueue/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_characters_character_id_skillqueue
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_skillqueue(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_skillqueue_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/skillqueue/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_skillsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/skills/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List all trained skills for the given character

---
Alternate route: `/dev/characters/{character_id}/skills/`

Alternate route: `/v4/characters/{character_id}/skills/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_characters_character_id_skills
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_skills(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_skills_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/skills/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_standingsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/standings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return character standings from agents, NPC corporations, and factions

---
Alternate route: `/dev/characters/{character_id}/standings/`

Alternate route: `/legacy/characters/{character_id}/standings/`

Alternate route: `/v1/characters/{character_id}/standings/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_standings
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_standings(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_standings_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/standings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_statsURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns aggregate yearly stats for a character

---
Alternate route: `/dev/characters/{character_id}/stats/`

Alternate route: `/v2/characters/{character_id}/stats/`

---
This route is cached for up to 86400 seconds
    * @method
    * @name Esi#get_characters_character_id_stats
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_stats(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_stats_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_titlesURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/titles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a character's titles

---
Alternate route: `/dev/characters/{character_id}/titles/`

Alternate route: `/legacy/characters/{character_id}/titles/`

Alternate route: `/v1/characters/{character_id}/titles/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_titles
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_titles(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_titles_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/titles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_walletURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/wallet/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a character's wallet balance

---
Alternate route: `/legacy/characters/{character_id}/wallet/`

Alternate route: `/v1/characters/{character_id}/wallet/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_characters_character_id_wallet
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_wallet(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_wallet_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/wallet/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_wallet_journalURL(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/wallet/journal/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Retrieve the given character's wallet journal going 30 days back

---
Alternate route: `/dev/characters/{character_id}/wallet/journal/`

Alternate route: `/v6/characters/{character_id}/wallet/journal/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_wallet_journal
         * @param {integer} characterId - An EVE character ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_wallet_journal(parameters: {
        'characterId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_wallet_journal_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/wallet/journal/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_characters_character_id_wallet_transactionsURL(parameters: {
        'characterId': number,
        'fromId' ? : number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/wallet/transactions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{character_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['characterId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['fromId'] !== undefined) {
            queryParameters['from_id'] = this.convertParameterCollectionFormat(
                parameters['fromId'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get wallet transactions of a character

---
Alternate route: `/dev/characters/{character_id}/wallet/transactions/`

Alternate route: `/legacy/characters/{character_id}/wallet/transactions/`

Alternate route: `/v1/characters/{character_id}/wallet/transactions/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_characters_character_id_wallet_transactions
         * @param {integer} characterId - An EVE character ID

         * @param {integer} fromId - Only show transactions happened before the one referenced by this id
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_characters_character_id_wallet_transactions(parameters: {
        'characterId': number,
        'fromId' ? : number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_characters_character_id_wallet_transactions_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/characters/{character_id}/wallet/transactions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{character_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['characterId'],
                    ''
                ).toString())}`
            );

            if (parameters['characterId'] === undefined) {
                reject(new Error('Missing required  parameter: characterId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['fromId'] !== undefined) {
                queryParameters['from_id'] = this.convertParameterCollectionFormat(
                    parameters['fromId'],
                    ''
                );
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_contracts_public_bids_contract_idURL(parameters: {
        'contractId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/contracts/public/bids/{contract_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{contract_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['contractId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Lists bids on a public auction contract

---
Alternate route: `/dev/contracts/public/bids/{contract_id}/`

Alternate route: `/legacy/contracts/public/bids/{contract_id}/`

Alternate route: `/v1/contracts/public/bids/{contract_id}/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_contracts_public_bids_contract_id
         * @param {integer} contractId - ID of a contract

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
    */
    get_contracts_public_bids_contract_id(parameters: {
        'contractId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_contracts_public_bids_contract_id_200 > | ResponseWithBody < 204, void > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 403, Response_get_contracts_public_bids_contract_id_403 > | ResponseWithBody < 404, Response_get_contracts_public_bids_contract_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/contracts/public/bids/{contract_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{contract_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['contractId'],
                    ''
                ).toString())}`
            );

            if (parameters['contractId'] === undefined) {
                reject(new Error('Missing required  parameter: contractId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_contracts_public_items_contract_idURL(parameters: {
        'contractId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/contracts/public/items/{contract_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{contract_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['contractId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Lists items of a public contract

---
Alternate route: `/dev/contracts/public/items/{contract_id}/`

Alternate route: `/legacy/contracts/public/items/{contract_id}/`

Alternate route: `/v1/contracts/public/items/{contract_id}/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_contracts_public_items_contract_id
         * @param {integer} contractId - ID of a contract

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
    */
    get_contracts_public_items_contract_id(parameters: {
        'contractId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_contracts_public_items_contract_id_200 > | ResponseWithBody < 204, void > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 403, Response_get_contracts_public_items_contract_id_403 > | ResponseWithBody < 404, Response_get_contracts_public_items_contract_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/contracts/public/items/{contract_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{contract_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['contractId'],
                    ''
                ).toString())}`
            );

            if (parameters['contractId'] === undefined) {
                reject(new Error('Missing required  parameter: contractId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_contracts_public_region_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'regionId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/contracts/public/{region_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        path = path.replace(
            '{region_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['regionId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a paginated list of all public contracts in the given region

---
Alternate route: `/dev/contracts/public/{region_id}/`

Alternate route: `/legacy/contracts/public/{region_id}/`

Alternate route: `/v1/contracts/public/{region_id}/`

---
This route is cached for up to 1800 seconds
    * @method
    * @name Esi#get_contracts_public_region_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {integer} regionId - An EVE region id
    */
    get_contracts_public_region_id(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'regionId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_contracts_public_region_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_contracts_public_region_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/contracts/public/{region_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            path = path.replace(
                '{region_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['regionId'],
                    ''
                ).toString())}`
            );

            if (parameters['regionId'] === undefined) {
                reject(new Error('Missing required  parameter: regionId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporation_corporation_id_mining_extractionsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporation/{corporation_id}/mining/extractions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Extraction timers for all moon chunks being extracted by refineries belonging to a corporation.


---
Alternate route: `/dev/corporation/{corporation_id}/mining/extractions/`

Alternate route: `/legacy/corporation/{corporation_id}/mining/extractions/`

Alternate route: `/v1/corporation/{corporation_id}/mining/extractions/`

---
This route is cached for up to 1800 seconds

---
Requires one of the following EVE corporation role(s): Station_Manager

    * @method
    * @name Esi#get_corporation_corporation_id_mining_extractions
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporation_corporation_id_mining_extractions(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporation_corporation_id_mining_extractions_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporation/{corporation_id}/mining/extractions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporation_corporation_id_mining_observersURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporation/{corporation_id}/mining/observers/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Paginated list of all entities capable of observing and recording mining for a corporation


---
Alternate route: `/dev/corporation/{corporation_id}/mining/observers/`

Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/`

Alternate route: `/v1/corporation/{corporation_id}/mining/observers/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Accountant

    * @method
    * @name Esi#get_corporation_corporation_id_mining_observers
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporation_corporation_id_mining_observers(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporation_corporation_id_mining_observers_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporation/{corporation_id}/mining/observers/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporation_corporation_id_mining_observers_observer_idURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'observerId': number,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporation/{corporation_id}/mining/observers/{observer_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{observer_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['observerId'],
                        ''
                    ).toString())}`
        );
        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Paginated record of all mining seen by an observer


---
Alternate route: `/dev/corporation/{corporation_id}/mining/observers/{observer_id}/`

Alternate route: `/legacy/corporation/{corporation_id}/mining/observers/{observer_id}/`

Alternate route: `/v1/corporation/{corporation_id}/mining/observers/{observer_id}/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Accountant

    * @method
    * @name Esi#get_corporation_corporation_id_mining_observers_observer_id
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} observerId - A mining observer id
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporation_corporation_id_mining_observers_observer_id(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'observerId': number,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporation_corporation_id_mining_observers_observer_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporation/{corporation_id}/mining/observers/{observer_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{observer_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['observerId'],
                    ''
                ).toString())}`
            );

            if (parameters['observerId'] === undefined) {
                reject(new Error('Missing required  parameter: observerId'));
                return;
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_npccorpsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/npccorps/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of npc corporations

---
Alternate route: `/dev/corporations/npccorps/`

Alternate route: `/legacy/corporations/npccorps/`

Alternate route: `/v1/corporations/npccorps/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_corporations_npccorps

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_corporations_npccorps(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_npccorps_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/npccorps/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_idURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Public information about a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/`

Alternate route: `/v4/corporations/{corporation_id}/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_corporations_corporation_id(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_corporations_corporation_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_alliancehistoryURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/alliancehistory/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of all the alliances a corporation has been a member of

---
Alternate route: `/dev/corporations/{corporation_id}/alliancehistory/`

Alternate route: `/v2/corporations/{corporation_id}/alliancehistory/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_alliancehistory
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_corporations_corporation_id_alliancehistory(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_alliancehistory_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/alliancehistory/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_assetsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/assets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of the corporation assets

---
Alternate route: `/dev/corporations/{corporation_id}/assets/`

Alternate route: `/v4/corporations/{corporation_id}/assets/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_assets
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_assets(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_assets_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/assets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_corporations_corporation_id_assets_locationsURL(parameters: {
        'corporationId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/assets/locations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return locations for a set of item ids, which you can get from corporation assets endpoint. Coordinates for items in hangars or stations are set to (0,0,0)

---
Alternate route: `/dev/corporations/{corporation_id}/assets/locations/`

Alternate route: `/v2/corporations/{corporation_id}/assets/locations/`


---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#post_corporations_corporation_id_assets_locations
         * @param {integer} corporationId - An EVE corporation ID

         * @param {} itemIds - A list of item ids
         * @param {string} token - Access token to use if unable to set a header
    */
    post_corporations_corporation_id_assets_locations(parameters: {
        'corporationId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_post_corporations_corporation_id_assets_locations_200 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_post_corporations_corporation_id_assets_locations_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/assets/locations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['itemIds'] !== undefined) {
                body = parameters['itemIds'];
            }

            if (parameters['itemIds'] === undefined) {
                reject(new Error('Missing required  parameter: itemIds'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_corporations_corporation_id_assets_namesURL(parameters: {
        'corporationId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/assets/names/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return names for a set of item ids, which you can get from corporation assets endpoint. Only valid for items that can customize names, like containers or ships

---
Alternate route: `/dev/corporations/{corporation_id}/assets/names/`

Alternate route: `/legacy/corporations/{corporation_id}/assets/names/`

Alternate route: `/v1/corporations/{corporation_id}/assets/names/`


---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#post_corporations_corporation_id_assets_names
         * @param {integer} corporationId - An EVE corporation ID

         * @param {} itemIds - A list of item ids
         * @param {string} token - Access token to use if unable to set a header
    */
    post_corporations_corporation_id_assets_names(parameters: {
        'corporationId': number,
        'itemIds': Array < number >
            ,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_post_corporations_corporation_id_assets_names_200 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_post_corporations_corporation_id_assets_names_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/assets/names/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['itemIds'] !== undefined) {
                body = parameters['itemIds'];
            }

            if (parameters['itemIds'] === undefined) {
                reject(new Error('Missing required  parameter: itemIds'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_blueprintsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/blueprints/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a list of blueprints the corporation owns

---
Alternate route: `/dev/corporations/{corporation_id}/blueprints/`

Alternate route: `/v2/corporations/{corporation_id}/blueprints/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_blueprints
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_blueprints(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_blueprints_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/blueprints/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_bookmarksURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/bookmarks/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * A list of your corporation's bookmarks

---
Alternate route: `/dev/corporations/{corporation_id}/bookmarks/`

Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/`

Alternate route: `/v1/corporations/{corporation_id}/bookmarks/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_bookmarks
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_bookmarks(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_bookmarks_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/bookmarks/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_bookmarks_foldersURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/bookmarks/folders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * A list of your corporation's bookmark folders

---
Alternate route: `/dev/corporations/{corporation_id}/bookmarks/folders/`

Alternate route: `/legacy/corporations/{corporation_id}/bookmarks/folders/`

Alternate route: `/v1/corporations/{corporation_id}/bookmarks/folders/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_bookmarks_folders
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_bookmarks_folders(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_bookmarks_folders_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/bookmarks/folders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_contactsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return contacts of a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/contacts/`

Alternate route: `/v2/corporations/{corporation_id}/contacts/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_contacts
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_contacts(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_contacts_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contacts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_contacts_labelsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contacts/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return custom labels for a corporation's contacts

---
Alternate route: `/dev/corporations/{corporation_id}/contacts/labels/`

Alternate route: `/legacy/corporations/{corporation_id}/contacts/labels/`

Alternate route: `/v1/corporations/{corporation_id}/contacts/labels/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_contacts_labels
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_contacts_labels(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_contacts_labels_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contacts/labels/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_containers_logsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/containers/logs/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns logs recorded in the past seven days from all audit log secure containers (ALSC) owned by a given corporation

---
Alternate route: `/dev/corporations/{corporation_id}/containers/logs/`

Alternate route: `/v2/corporations/{corporation_id}/containers/logs/`

---
This route is cached for up to 600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_containers_logs
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_containers_logs(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_containers_logs_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/containers/logs/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_contractsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contracts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns contracts available to a corporation, only if the corporation is issuer, acceptor or assignee. Only returns contracts no older than 30 days, or if the status is "in_progress".

---
Alternate route: `/dev/corporations/{corporation_id}/contracts/`

Alternate route: `/legacy/corporations/{corporation_id}/contracts/`

Alternate route: `/v1/corporations/{corporation_id}/contracts/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_contracts
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_contracts(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_contracts_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contracts/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_contracts_contract_id_bidsURL(parameters: {
        'contractId': number,
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contracts/{contract_id}/bids/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{contract_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['contractId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Lists bids on a particular auction contract

---
Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/bids/`

Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/bids/`

Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/bids/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_contracts_contract_id_bids
         * @param {integer} contractId - ID of a contract
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_contracts_contract_id_bids(parameters: {
        'contractId': number,
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_contracts_contract_id_bids_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_corporations_corporation_id_contracts_contract_id_bids_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contracts/{contract_id}/bids/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{contract_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['contractId'],
                    ''
                ).toString())}`
            );

            if (parameters['contractId'] === undefined) {
                reject(new Error('Missing required  parameter: contractId'));
                return;
            }

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_contracts_contract_id_itemsURL(parameters: {
        'contractId': number,
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contracts/{contract_id}/items/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{contract_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['contractId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Lists items of a particular contract

---
Alternate route: `/dev/corporations/{corporation_id}/contracts/{contract_id}/items/`

Alternate route: `/legacy/corporations/{corporation_id}/contracts/{contract_id}/items/`

Alternate route: `/v1/corporations/{corporation_id}/contracts/{contract_id}/items/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_contracts_contract_id_items
         * @param {integer} contractId - ID of a contract
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_contracts_contract_id_items(parameters: {
        'contractId': number,
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_contracts_contract_id_items_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_corporations_corporation_id_contracts_contract_id_items_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout > | ResponseWithBody < 520, Response_get_corporations_corporation_id_contracts_contract_id_items_520 >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/contracts/{contract_id}/items/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{contract_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['contractId'],
                    ''
                ).toString())}`
            );

            if (parameters['contractId'] === undefined) {
                reject(new Error('Missing required  parameter: contractId'));
                return;
            }

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_customs_officesURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/customs_offices/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List customs offices owned by a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/customs_offices/`

Alternate route: `/legacy/corporations/{corporation_id}/customs_offices/`

Alternate route: `/v1/corporations/{corporation_id}/customs_offices/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_customs_offices
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_customs_offices(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_customs_offices_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/customs_offices/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_divisionsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/divisions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return corporation hangar and wallet division names, only show if a division is not using the default name

---
Alternate route: `/dev/corporations/{corporation_id}/divisions/`

Alternate route: `/legacy/corporations/{corporation_id}/divisions/`

Alternate route: `/v1/corporations/{corporation_id}/divisions/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_divisions
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_divisions(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_divisions_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/divisions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_facilitiesURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/facilities/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a corporation's facilities

---
Alternate route: `/dev/corporations/{corporation_id}/facilities/`

Alternate route: `/legacy/corporations/{corporation_id}/facilities/`

Alternate route: `/v1/corporations/{corporation_id}/facilities/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Factory_Manager

    * @method
    * @name Esi#get_corporations_corporation_id_facilities
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_facilities(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_facilities_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/facilities/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_fw_statsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/fw/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Statistics about a corporation involved in faction warfare

---
Alternate route: `/legacy/corporations/{corporation_id}/fw/stats/`

Alternate route: `/v1/corporations/{corporation_id}/fw/stats/`

---
This route expires daily at 11:05

---
[Diff of the upcoming changes](https://esi.evetech.net/diff/latest/dev/#GET-/corporations/{corporation_id}/fw/stats/)
    * @method
    * @name Esi#get_corporations_corporation_id_fw_stats
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_fw_stats(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_fw_stats_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/fw/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_iconsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/icons/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get the icon urls for a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/icons/`

Alternate route: `/legacy/corporations/{corporation_id}/icons/`

Alternate route: `/v1/corporations/{corporation_id}/icons/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_icons
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_corporations_corporation_id_icons(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_icons_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_corporations_corporation_id_icons_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/icons/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_industry_jobsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'includeCompleted' ? : boolean,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/industry/jobs/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['includeCompleted'] !== undefined) {
            queryParameters['include_completed'] = this.convertParameterCollectionFormat(
                parameters['includeCompleted'],
                ''
            );
        }

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List industry jobs run by a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/industry/jobs/`

Alternate route: `/legacy/corporations/{corporation_id}/industry/jobs/`

Alternate route: `/v1/corporations/{corporation_id}/industry/jobs/`

---
This route is cached for up to 300 seconds

---
Requires one of the following EVE corporation role(s): Factory_Manager

    * @method
    * @name Esi#get_corporations_corporation_id_industry_jobs
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {boolean} includeCompleted - Whether to retrieve completed corporation industry jobs. Only includes jobs from the past 90 days
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_industry_jobs(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'includeCompleted' ? : boolean,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_industry_jobs_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/industry/jobs/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['includeCompleted'] !== undefined) {
                queryParameters['include_completed'] = this.convertParameterCollectionFormat(
                    parameters['includeCompleted'],
                    ''
                );
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_killmails_recentURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/killmails/recent/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of a corporation's kills and losses going back 90 days

---
Alternate route: `/dev/corporations/{corporation_id}/killmails/recent/`

Alternate route: `/legacy/corporations/{corporation_id}/killmails/recent/`

Alternate route: `/v1/corporations/{corporation_id}/killmails/recent/`

---
This route is cached for up to 300 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_killmails_recent
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_killmails_recent(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_killmails_recent_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/killmails/recent/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_medalsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/medals/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a corporation's medals

---
Alternate route: `/dev/corporations/{corporation_id}/medals/`

Alternate route: `/legacy/corporations/{corporation_id}/medals/`

Alternate route: `/v1/corporations/{corporation_id}/medals/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_medals
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_medals(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_medals_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/medals/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_medals_issuedURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/medals/issued/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns medals issued by a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/medals/issued/`

Alternate route: `/legacy/corporations/{corporation_id}/medals/issued/`

Alternate route: `/v1/corporations/{corporation_id}/medals/issued/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_medals_issued
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_medals_issued(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_medals_issued_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/medals/issued/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_membersURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/members/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return the current member list of a corporation, the token's character need to be a member of the corporation.

---
Alternate route: `/dev/corporations/{corporation_id}/members/`

Alternate route: `/v3/corporations/{corporation_id}/members/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_members
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_members(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_members_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/members/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_members_limitURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/members/limit/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a corporation's member limit, not including CEO himself

---
Alternate route: `/dev/corporations/{corporation_id}/members/limit/`

Alternate route: `/legacy/corporations/{corporation_id}/members/limit/`

Alternate route: `/v1/corporations/{corporation_id}/members/limit/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_members_limit
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_members_limit(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_members_limit_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/members/limit/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_members_titlesURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/members/titles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a corporation's members' titles

---
Alternate route: `/dev/corporations/{corporation_id}/members/titles/`

Alternate route: `/legacy/corporations/{corporation_id}/members/titles/`

Alternate route: `/v1/corporations/{corporation_id}/members/titles/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_members_titles
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_members_titles(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_members_titles_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/members/titles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_membertrackingURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/membertracking/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns additional information about a corporation's members which helps tracking their activities

---
Alternate route: `/dev/corporations/{corporation_id}/membertracking/`

Alternate route: `/legacy/corporations/{corporation_id}/membertracking/`

Alternate route: `/v1/corporations/{corporation_id}/membertracking/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_membertracking
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_membertracking(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_membertracking_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/membertracking/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_ordersURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/orders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List open market orders placed on behalf of a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/orders/`

Alternate route: `/v3/corporations/{corporation_id}/orders/`

---
This route is cached for up to 1200 seconds

---
Requires one of the following EVE corporation role(s): Accountant, Trader

    * @method
    * @name Esi#get_corporations_corporation_id_orders
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_orders(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_orders_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/orders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_orders_historyURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/orders/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List cancelled and expired market orders placed on behalf of a corporation up to 90 days in the past.

---
Alternate route: `/dev/corporations/{corporation_id}/orders/history/`

Alternate route: `/v2/corporations/{corporation_id}/orders/history/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Accountant, Trader

    * @method
    * @name Esi#get_corporations_corporation_id_orders_history
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_orders_history(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_orders_history_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/orders/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_rolesURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/roles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return the roles of all members if the character has the personnel manager role or any grantable role.

---
Alternate route: `/dev/corporations/{corporation_id}/roles/`

Alternate route: `/legacy/corporations/{corporation_id}/roles/`

Alternate route: `/v1/corporations/{corporation_id}/roles/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_roles
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_roles(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_roles_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/roles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_roles_historyURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/roles/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return how roles have changed for a coporation's members, up to a month

---
Alternate route: `/dev/corporations/{corporation_id}/roles/history/`

Alternate route: `/legacy/corporations/{corporation_id}/roles/history/`

Alternate route: `/v1/corporations/{corporation_id}/roles/history/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_roles_history
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_roles_history(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_roles_history_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/roles/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_shareholdersURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/shareholders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return the current shareholders of a corporation.

---
Alternate route: `/dev/corporations/{corporation_id}/shareholders/`

Alternate route: `/legacy/corporations/{corporation_id}/shareholders/`

Alternate route: `/v1/corporations/{corporation_id}/shareholders/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_shareholders
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_shareholders(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_shareholders_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/shareholders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_standingsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/standings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return corporation standings from agents, NPC corporations, and factions

---
Alternate route: `/dev/corporations/{corporation_id}/standings/`

Alternate route: `/legacy/corporations/{corporation_id}/standings/`

Alternate route: `/v1/corporations/{corporation_id}/standings/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_corporations_corporation_id_standings
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_standings(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_standings_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/standings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_starbasesURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/starbases/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns list of corporation starbases (POSes)

---
Alternate route: `/dev/corporations/{corporation_id}/starbases/`

Alternate route: `/legacy/corporations/{corporation_id}/starbases/`

Alternate route: `/v1/corporations/{corporation_id}/starbases/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_starbases
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_starbases(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_starbases_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/starbases/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_starbases_starbase_idURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'starbaseId': number,
        'systemId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/starbases/{starbase_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{starbase_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['starbaseId'],
                        ''
                    ).toString())}`
        );
        if (parameters['systemId'] !== undefined) {
            queryParameters['system_id'] = this.convertParameterCollectionFormat(
                parameters['systemId'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns various settings and fuels of a starbase (POS)

---
Alternate route: `/dev/corporations/{corporation_id}/starbases/{starbase_id}/`

Alternate route: `/legacy/corporations/{corporation_id}/starbases/{starbase_id}/`

Alternate route: `/v1/corporations/{corporation_id}/starbases/{starbase_id}/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_starbases_starbase_id
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} starbaseId - An EVE starbase (POS) ID
         * @param {integer} systemId - The solar system this starbase (POS) is located in,
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_starbases_starbase_id(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'starbaseId': number,
        'systemId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_starbases_starbase_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/starbases/{starbase_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{starbase_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['starbaseId'],
                    ''
                ).toString())}`
            );

            if (parameters['starbaseId'] === undefined) {
                reject(new Error('Missing required  parameter: starbaseId'));
                return;
            }

            if (parameters['systemId'] !== undefined) {
                queryParameters['system_id'] = this.convertParameterCollectionFormat(
                    parameters['systemId'],
                    ''
                );
            }

            if (parameters['systemId'] === undefined) {
                reject(new Error('Missing required  parameter: systemId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_structuresURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/structures/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of corporation structures. This route's version includes the changes to structures detailed in this blog: https://www.eveonline.com/article/upwell-2.0-structures-changes-coming-on-february-13th

---
Alternate route: `/dev/corporations/{corporation_id}/structures/`

Alternate route: `/v3/corporations/{corporation_id}/structures/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Station_Manager

    * @method
    * @name Esi#get_corporations_corporation_id_structures
         * @param {string} acceptLanguage - Language to use in the response
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_structures(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_structures_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/structures/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_titlesURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/titles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns a corporation's titles

---
Alternate route: `/dev/corporations/{corporation_id}/titles/`

Alternate route: `/legacy/corporations/{corporation_id}/titles/`

Alternate route: `/v1/corporations/{corporation_id}/titles/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Director

    * @method
    * @name Esi#get_corporations_corporation_id_titles
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_titles(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_titles_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/titles/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_walletsURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/wallets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a corporation's wallets

---
Alternate route: `/dev/corporations/{corporation_id}/wallets/`

Alternate route: `/legacy/corporations/{corporation_id}/wallets/`

Alternate route: `/v1/corporations/{corporation_id}/wallets/`

---
This route is cached for up to 300 seconds

---
Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant

    * @method
    * @name Esi#get_corporations_corporation_id_wallets
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_wallets(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_wallets_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/wallets/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_wallets_division_journalURL(parameters: {
        'corporationId': number,
        'division': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/wallets/{division}/journal/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{division}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['division'],
                        ''
                    ).toString())}`
        );

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Retrieve the given corporation's wallet journal for the given division going 30 days back

---
Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/journal/`

Alternate route: `/v4/corporations/{corporation_id}/wallets/{division}/journal/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant

    * @method
    * @name Esi#get_corporations_corporation_id_wallets_division_journal
         * @param {integer} corporationId - An EVE corporation ID

         * @param {integer} division - Wallet key of the division to fetch journals from
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_wallets_division_journal(parameters: {
        'corporationId': number,
        'division': number,
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_wallets_division_journal_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/wallets/{division}/journal/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{division}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['division'],
                    ''
                ).toString())}`
            );

            if (parameters['division'] === undefined) {
                reject(new Error('Missing required  parameter: division'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_corporations_corporation_id_wallets_division_transactionsURL(parameters: {
        'corporationId': number,
        'division': number,
        'fromId' ? : number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/wallets/{division}/transactions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{division}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['division'],
                        ''
                    ).toString())}`
        );
        if (parameters['fromId'] !== undefined) {
            queryParameters['from_id'] = this.convertParameterCollectionFormat(
                parameters['fromId'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get wallet transactions of a corporation

---
Alternate route: `/dev/corporations/{corporation_id}/wallets/{division}/transactions/`

Alternate route: `/legacy/corporations/{corporation_id}/wallets/{division}/transactions/`

Alternate route: `/v1/corporations/{corporation_id}/wallets/{division}/transactions/`

---
This route is cached for up to 3600 seconds

---
Requires one of the following EVE corporation role(s): Accountant, Junior_Accountant

    * @method
    * @name Esi#get_corporations_corporation_id_wallets_division_transactions
         * @param {integer} corporationId - An EVE corporation ID

         * @param {integer} division - Wallet key of the division to fetch journals from
         * @param {integer} fromId - Only show journal entries happened before the transaction referenced by this id
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_corporations_corporation_id_wallets_division_transactions(parameters: {
        'corporationId': number,
        'division': number,
        'fromId' ? : number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_corporations_corporation_id_wallets_division_transactions_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/corporations/{corporation_id}/wallets/{division}/transactions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{division}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['division'],
                    ''
                ).toString())}`
            );

            if (parameters['division'] === undefined) {
                reject(new Error('Missing required  parameter: division'));
                return;
            }

            if (parameters['fromId'] !== undefined) {
                queryParameters['from_id'] = this.convertParameterCollectionFormat(
                    parameters['fromId'],
                    ''
                );
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_dogma_attributesURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/attributes/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of dogma attribute ids

---
Alternate route: `/dev/dogma/attributes/`

Alternate route: `/legacy/dogma/attributes/`

Alternate route: `/v1/dogma/attributes/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_dogma_attributes

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_dogma_attributes(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_dogma_attributes_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/attributes/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_dogma_attributes_attribute_idURL(parameters: {
        'attributeId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/attributes/{attribute_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{attribute_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['attributeId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a dogma attribute

---
Alternate route: `/dev/dogma/attributes/{attribute_id}/`

Alternate route: `/legacy/dogma/attributes/{attribute_id}/`

Alternate route: `/v1/dogma/attributes/{attribute_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_dogma_attributes_attribute_id
         * @param {integer} attributeId - A dogma attribute ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_dogma_attributes_attribute_id(parameters: {
        'attributeId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_dogma_attributes_attribute_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_dogma_attributes_attribute_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/attributes/{attribute_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{attribute_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['attributeId'],
                    ''
                ).toString())}`
            );

            if (parameters['attributeId'] === undefined) {
                reject(new Error('Missing required  parameter: attributeId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_dogma_dynamic_items_type_id_item_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'itemId': number,
        'typeId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/dynamic/items/{type_id}/{item_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{item_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['itemId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{type_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['typeId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns info about a dynamic item resulting from mutation with a mutaplasmid.

---
Alternate route: `/dev/dogma/dynamic/items/{type_id}/{item_id}/`

Alternate route: `/legacy/dogma/dynamic/items/{type_id}/{item_id}/`

Alternate route: `/v1/dogma/dynamic/items/{type_id}/{item_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_dogma_dynamic_items_type_id_item_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} itemId - item_id integer
         * @param {integer} typeId - type_id integer
    */
    get_dogma_dynamic_items_type_id_item_id(parameters: {
        'ifNoneMatch' ? : string,
        'itemId': number,
        'typeId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_dogma_dynamic_items_type_id_item_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_dogma_dynamic_items_type_id_item_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/dynamic/items/{type_id}/{item_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{item_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['itemId'],
                    ''
                ).toString())}`
            );

            if (parameters['itemId'] === undefined) {
                reject(new Error('Missing required  parameter: itemId'));
                return;
            }

            path = path.replace(
                '{type_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['typeId'],
                    ''
                ).toString())}`
            );

            if (parameters['typeId'] === undefined) {
                reject(new Error('Missing required  parameter: typeId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_dogma_effectsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/effects/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of dogma effect ids

---
Alternate route: `/dev/dogma/effects/`

Alternate route: `/legacy/dogma/effects/`

Alternate route: `/v1/dogma/effects/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_dogma_effects

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_dogma_effects(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_dogma_effects_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/effects/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_dogma_effects_effect_idURL(parameters: {
        'effectId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/effects/{effect_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{effect_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['effectId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a dogma effect

---
Alternate route: `/dev/dogma/effects/{effect_id}/`

Alternate route: `/v2/dogma/effects/{effect_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_dogma_effects_effect_id

         * @param {integer} effectId - A dogma effect ID
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_dogma_effects_effect_id(parameters: {
        'effectId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_dogma_effects_effect_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_dogma_effects_effect_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/dogma/effects/{effect_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{effect_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['effectId'],
                    ''
                ).toString())}`
            );

            if (parameters['effectId'] === undefined) {
                reject(new Error('Missing required  parameter: effectId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fleets_fleet_idURL(parameters: {
        'fleetId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return details about a fleet

---
Alternate route: `/dev/fleets/{fleet_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/`

Alternate route: `/v1/fleets/{fleet_id}/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_fleets_fleet_id

         * @param {integer} fleetId - ID for a fleet
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} token - Access token to use if unable to set a header
    */
    get_fleets_fleet_id(parameters: {
        'fleetId': number,
        'ifNoneMatch' ? : string,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fleets_fleet_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_fleets_fleet_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    put_fleets_fleet_idURL(parameters: {
        'fleetId': number,
        'newSettings': {
            'is_free_move' ? : boolean;
            'motd' ? : string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Update settings about a fleet

---
Alternate route: `/dev/fleets/{fleet_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/`

Alternate route: `/v1/fleets/{fleet_id}/`

    * @method
    * @name Esi#put_fleets_fleet_id

         * @param {integer} fleetId - ID for a fleet
         * @param {} newSettings - What to update for this fleet
         * @param {string} token - Access token to use if unable to set a header
    */
    put_fleets_fleet_id(parameters: {
        'fleetId': number,
        'newSettings': {
            'is_free_move' ? : boolean;
            'motd' ? : string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_put_fleets_fleet_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['newSettings'] !== undefined) {
                body = parameters['newSettings'];
            }

            if (parameters['newSettings'] === undefined) {
                reject(new Error('Missing required  parameter: newSettings'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fleets_fleet_id_membersURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'fleetId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return information about fleet members

---
Alternate route: `/dev/fleets/{fleet_id}/members/`

Alternate route: `/legacy/fleets/{fleet_id}/members/`

Alternate route: `/v1/fleets/{fleet_id}/members/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_fleets_fleet_id_members
         * @param {string} acceptLanguage - Language to use in the response

         * @param {integer} fleetId - ID for a fleet
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {string} token - Access token to use if unable to set a header
    */
    get_fleets_fleet_id_members(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'fleetId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fleets_fleet_id_members_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_fleets_fleet_id_members_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_fleets_fleet_id_membersURL(parameters: {
        'fleetId': number,
        'invitation': {
            'character_id': number;
            'role': "fleet_commander" | "wing_commander" | "squad_commander" | "squad_member";
            'squad_id' ? : number;
            'wing_id' ? : number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Invite a character into the fleet. If a character has a CSPA charge set it is not possible to invite them to the fleet using ESI

---
Alternate route: `/dev/fleets/{fleet_id}/members/`

Alternate route: `/legacy/fleets/{fleet_id}/members/`

Alternate route: `/v1/fleets/{fleet_id}/members/`

    * @method
    * @name Esi#post_fleets_fleet_id_members

         * @param {integer} fleetId - ID for a fleet
         * @param {} invitation - Details of the invitation
         * @param {string} token - Access token to use if unable to set a header
    */
    post_fleets_fleet_id_members(parameters: {
        'fleetId': number,
        'invitation': {
            'character_id': number;
            'role': "fleet_commander" | "wing_commander" | "squad_commander" | "squad_member";
            'squad_id' ? : number;
            'wing_id' ? : number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_post_fleets_fleet_id_members_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_post_fleets_fleet_id_members_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['invitation'] !== undefined) {
                body = parameters['invitation'];
            }

            if (parameters['invitation'] === undefined) {
                reject(new Error('Missing required  parameter: invitation'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    delete_fleets_fleet_id_members_member_idURL(parameters: {
        'fleetId': number,
        'memberId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/{member_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{member_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['memberId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Kick a fleet member

---
Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`

Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`

    * @method
    * @name Esi#delete_fleets_fleet_id_members_member_id

         * @param {integer} fleetId - ID for a fleet
         * @param {integer} memberId - The character ID of a member in this fleet
         * @param {string} token - Access token to use if unable to set a header
    */
    delete_fleets_fleet_id_members_member_id(parameters: {
        'fleetId': number,
        'memberId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_delete_fleets_fleet_id_members_member_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/{member_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            path = path.replace(
                '{member_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['memberId'],
                    ''
                ).toString())}`
            );

            if (parameters['memberId'] === undefined) {
                reject(new Error('Missing required  parameter: memberId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    put_fleets_fleet_id_members_member_idURL(parameters: {
        'fleetId': number,
        'memberId': number,
        'movement': {
            'role': "fleet_commander" | "wing_commander" | "squad_commander" | "squad_member";
            'squad_id' ? : number;
            'wing_id' ? : number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/{member_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{member_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['memberId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Move a fleet member around

---
Alternate route: `/dev/fleets/{fleet_id}/members/{member_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/members/{member_id}/`

Alternate route: `/v1/fleets/{fleet_id}/members/{member_id}/`

    * @method
    * @name Esi#put_fleets_fleet_id_members_member_id

         * @param {integer} fleetId - ID for a fleet
         * @param {integer} memberId - The character ID of a member in this fleet
         * @param {} movement - Details of the invitation
         * @param {string} token - Access token to use if unable to set a header
    */
    put_fleets_fleet_id_members_member_id(parameters: {
        'fleetId': number,
        'memberId': number,
        'movement': {
            'role': "fleet_commander" | "wing_commander" | "squad_commander" | "squad_member";
            'squad_id' ? : number;
            'wing_id' ? : number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_put_fleets_fleet_id_members_member_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_put_fleets_fleet_id_members_member_id_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/members/{member_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            path = path.replace(
                '{member_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['memberId'],
                    ''
                ).toString())}`
            );

            if (parameters['memberId'] === undefined) {
                reject(new Error('Missing required  parameter: memberId'));
                return;
            }

            if (parameters['movement'] !== undefined) {
                body = parameters['movement'];
            }

            if (parameters['movement'] === undefined) {
                reject(new Error('Missing required  parameter: movement'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    delete_fleets_fleet_id_squads_squad_idURL(parameters: {
        'fleetId': number,
        'squadId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/squads/{squad_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{squad_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['squadId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Delete a fleet squad, only empty squads can be deleted

---
Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`

Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`

    * @method
    * @name Esi#delete_fleets_fleet_id_squads_squad_id

         * @param {integer} fleetId - ID for a fleet
         * @param {integer} squadId - The squad to delete
         * @param {string} token - Access token to use if unable to set a header
    */
    delete_fleets_fleet_id_squads_squad_id(parameters: {
        'fleetId': number,
        'squadId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_delete_fleets_fleet_id_squads_squad_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/squads/{squad_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            path = path.replace(
                '{squad_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['squadId'],
                    ''
                ).toString())}`
            );

            if (parameters['squadId'] === undefined) {
                reject(new Error('Missing required  parameter: squadId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    put_fleets_fleet_id_squads_squad_idURL(parameters: {
        'fleetId': number,
        'naming': {
            'name': string;
        } & {
            [key: string]: any;
        },
        'squadId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/squads/{squad_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{squad_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['squadId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Rename a fleet squad

---
Alternate route: `/dev/fleets/{fleet_id}/squads/{squad_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/squads/{squad_id}/`

Alternate route: `/v1/fleets/{fleet_id}/squads/{squad_id}/`

    * @method
    * @name Esi#put_fleets_fleet_id_squads_squad_id

         * @param {integer} fleetId - ID for a fleet
         * @param {} naming - New name of the squad
         * @param {integer} squadId - The squad to rename
         * @param {string} token - Access token to use if unable to set a header
    */
    put_fleets_fleet_id_squads_squad_id(parameters: {
        'fleetId': number,
        'naming': {
            'name': string;
        } & {
            [key: string]: any;
        },
        'squadId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_put_fleets_fleet_id_squads_squad_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/squads/{squad_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['naming'] !== undefined) {
                body = parameters['naming'];
            }

            if (parameters['naming'] === undefined) {
                reject(new Error('Missing required  parameter: naming'));
                return;
            }

            path = path.replace(
                '{squad_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['squadId'],
                    ''
                ).toString())}`
            );

            if (parameters['squadId'] === undefined) {
                reject(new Error('Missing required  parameter: squadId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fleets_fleet_id_wingsURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'fleetId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return information about wings in a fleet

---
Alternate route: `/dev/fleets/{fleet_id}/wings/`

Alternate route: `/legacy/fleets/{fleet_id}/wings/`

Alternate route: `/v1/fleets/{fleet_id}/wings/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_fleets_fleet_id_wings
         * @param {string} acceptLanguage - Language to use in the response

         * @param {integer} fleetId - ID for a fleet
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {string} token - Access token to use if unable to set a header
    */
    get_fleets_fleet_id_wings(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'fleetId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fleets_fleet_id_wings_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_fleets_fleet_id_wings_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_fleets_fleet_id_wingsURL(parameters: {
        'fleetId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Create a new wing in a fleet

---
Alternate route: `/dev/fleets/{fleet_id}/wings/`

Alternate route: `/legacy/fleets/{fleet_id}/wings/`

Alternate route: `/v1/fleets/{fleet_id}/wings/`

    * @method
    * @name Esi#post_fleets_fleet_id_wings

         * @param {integer} fleetId - ID for a fleet
         * @param {string} token - Access token to use if unable to set a header
    */
    post_fleets_fleet_id_wings(parameters: {
        'fleetId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 201, Response_post_fleets_fleet_id_wings_201 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_post_fleets_fleet_id_wings_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    delete_fleets_fleet_id_wings_wing_idURL(parameters: {
        'fleetId': number,
        'token' ? : string,
        'wingId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/{wing_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        path = path.replace(
            '{wing_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['wingId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Delete a fleet wing, only empty wings can be deleted. The wing may contain squads, but the squads must be empty

---
Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`

Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`

    * @method
    * @name Esi#delete_fleets_fleet_id_wings_wing_id

         * @param {integer} fleetId - ID for a fleet
         * @param {string} token - Access token to use if unable to set a header
         * @param {integer} wingId - The wing to delete
    */
    delete_fleets_fleet_id_wings_wing_id(parameters: {
        'fleetId': number,
        'token' ? : string,
        'wingId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_delete_fleets_fleet_id_wings_wing_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/{wing_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            path = path.replace(
                '{wing_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['wingId'],
                    ''
                ).toString())}`
            );

            if (parameters['wingId'] === undefined) {
                reject(new Error('Missing required  parameter: wingId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('DELETE', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    put_fleets_fleet_id_wings_wing_idURL(parameters: {
        'fleetId': number,
        'naming': {
            'name': string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
        'wingId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/{wing_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        path = path.replace(
            '{wing_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['wingId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Rename a fleet wing

---
Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/`

Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/`

Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/`

    * @method
    * @name Esi#put_fleets_fleet_id_wings_wing_id

         * @param {integer} fleetId - ID for a fleet
         * @param {} naming - New name of the wing
         * @param {string} token - Access token to use if unable to set a header
         * @param {integer} wingId - The wing to rename
    */
    put_fleets_fleet_id_wings_wing_id(parameters: {
        'fleetId': number,
        'naming': {
            'name': string;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
        'wingId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_put_fleets_fleet_id_wings_wing_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/{wing_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['naming'] !== undefined) {
                body = parameters['naming'];
            }

            if (parameters['naming'] === undefined) {
                reject(new Error('Missing required  parameter: naming'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            path = path.replace(
                '{wing_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['wingId'],
                    ''
                ).toString())}`
            );

            if (parameters['wingId'] === undefined) {
                reject(new Error('Missing required  parameter: wingId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('PUT', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_fleets_fleet_id_wings_wing_id_squadsURL(parameters: {
        'fleetId': number,
        'token' ? : string,
        'wingId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/{wing_id}/squads/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{fleet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['fleetId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        path = path.replace(
            '{wing_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['wingId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Create a new squad in a fleet

---
Alternate route: `/dev/fleets/{fleet_id}/wings/{wing_id}/squads/`

Alternate route: `/legacy/fleets/{fleet_id}/wings/{wing_id}/squads/`

Alternate route: `/v1/fleets/{fleet_id}/wings/{wing_id}/squads/`

    * @method
    * @name Esi#post_fleets_fleet_id_wings_wing_id_squads

         * @param {integer} fleetId - ID for a fleet
         * @param {string} token - Access token to use if unable to set a header
         * @param {integer} wingId - The wing_id to create squad in
    */
    post_fleets_fleet_id_wings_wing_id_squads(parameters: {
        'fleetId': number,
        'token' ? : string,
        'wingId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 201, Response_post_fleets_fleet_id_wings_wing_id_squads_201 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_post_fleets_fleet_id_wings_wing_id_squads_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fleets/{fleet_id}/wings/{wing_id}/squads/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{fleet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['fleetId'],
                    ''
                ).toString())}`
            );

            if (parameters['fleetId'] === undefined) {
                reject(new Error('Missing required  parameter: fleetId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            path = path.replace(
                '{wing_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['wingId'],
                    ''
                ).toString())}`
            );

            if (parameters['wingId'] === undefined) {
                reject(new Error('Missing required  parameter: wingId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fw_leaderboardsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/leaderboards/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Top 4 leaderboard of factions for kills and victory points separated by total, last week and yesterday

---
Alternate route: `/legacy/fw/leaderboards/`

Alternate route: `/v1/fw/leaderboards/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_fw_leaderboards

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_fw_leaderboards(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fw_leaderboards_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/leaderboards/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fw_leaderboards_charactersURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/leaderboards/characters/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Top 100 leaderboard of pilots for kills and victory points separated by total, last week and yesterday

---
Alternate route: `/legacy/fw/leaderboards/characters/`

Alternate route: `/v1/fw/leaderboards/characters/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_fw_leaderboards_characters

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_fw_leaderboards_characters(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fw_leaderboards_characters_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/leaderboards/characters/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fw_leaderboards_corporationsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/leaderboards/corporations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Top 10 leaderboard of corporations for kills and victory points separated by total, last week and yesterday

---
Alternate route: `/legacy/fw/leaderboards/corporations/`

Alternate route: `/v1/fw/leaderboards/corporations/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_fw_leaderboards_corporations

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_fw_leaderboards_corporations(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fw_leaderboards_corporations_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/leaderboards/corporations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fw_statsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Statistical overviews of factions involved in faction warfare

---
Alternate route: `/legacy/fw/stats/`

Alternate route: `/v1/fw/stats/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_fw_stats

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_fw_stats(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fw_stats_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/stats/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fw_systemsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/systems/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * An overview of the current ownership of faction warfare solar systems

---
Alternate route: `/v2/fw/systems/`

---
This route is cached for up to 1800 seconds
    * @method
    * @name Esi#get_fw_systems

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_fw_systems(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fw_systems_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/systems/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_fw_warsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/wars/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Data about which NPC factions are at war

---
Alternate route: `/legacy/fw/wars/`

Alternate route: `/v1/fw/wars/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_fw_wars

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_fw_wars(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_fw_wars_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/fw/wars/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_incursionsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/incursions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of current incursions

---
Alternate route: `/dev/incursions/`

Alternate route: `/legacy/incursions/`

Alternate route: `/v1/incursions/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_incursions

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_incursions(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_incursions_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/incursions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_industry_facilitiesURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/industry/facilities/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of industry facilities

---
Alternate route: `/dev/industry/facilities/`

Alternate route: `/legacy/industry/facilities/`

Alternate route: `/v1/industry/facilities/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_industry_facilities

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_industry_facilities(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_industry_facilities_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/industry/facilities/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_industry_systemsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/industry/systems/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return cost indices for solar systems

---
Alternate route: `/dev/industry/systems/`

Alternate route: `/legacy/industry/systems/`

Alternate route: `/v1/industry/systems/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_industry_systems

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_industry_systems(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_industry_systems_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/industry/systems/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_insurance_pricesURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/insurance/prices/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return available insurance levels for all ship types

---
Alternate route: `/dev/insurance/prices/`

Alternate route: `/legacy/insurance/prices/`

Alternate route: `/v1/insurance/prices/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_insurance_prices
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_insurance_prices(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_insurance_prices_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/insurance/prices/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_killmails_killmail_id_killmail_hashURL(parameters: {
        'ifNoneMatch' ? : string,
        'killmailHash': string,
        'killmailId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/killmails/{killmail_id}/{killmail_hash}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{killmail_hash}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['killmailHash'],
                        ''
                    ).toString())}`
        );

        path = path.replace(
            '{killmail_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['killmailId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a single killmail from its ID and hash

---
Alternate route: `/dev/killmails/{killmail_id}/{killmail_hash}/`

Alternate route: `/legacy/killmails/{killmail_id}/{killmail_hash}/`

Alternate route: `/v1/killmails/{killmail_id}/{killmail_hash}/`

---
This route is cached for up to 30758400 seconds
    * @method
    * @name Esi#get_killmails_killmail_id_killmail_hash

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} killmailHash - The killmail hash for verification
         * @param {integer} killmailId - The killmail ID to be queried
    */
    get_killmails_killmail_id_killmail_hash(parameters: {
        'ifNoneMatch' ? : string,
        'killmailHash': string,
        'killmailId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_killmails_killmail_id_killmail_hash_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_get_killmails_killmail_id_killmail_hash_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/killmails/{killmail_id}/{killmail_hash}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{killmail_hash}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['killmailHash'],
                    ''
                ).toString())}`
            );

            if (parameters['killmailHash'] === undefined) {
                reject(new Error('Missing required  parameter: killmailHash'));
                return;
            }

            path = path.replace(
                '{killmail_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['killmailId'],
                    ''
                ).toString())}`
            );

            if (parameters['killmailId'] === undefined) {
                reject(new Error('Missing required  parameter: killmailId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_loyalty_stores_corporation_id_offersURL(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/loyalty/stores/{corporation_id}/offers/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{corporation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['corporationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of offers from a specific corporation's loyalty store

---
Alternate route: `/dev/loyalty/stores/{corporation_id}/offers/`

Alternate route: `/legacy/loyalty/stores/{corporation_id}/offers/`

Alternate route: `/v1/loyalty/stores/{corporation_id}/offers/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_loyalty_stores_corporation_id_offers
         * @param {integer} corporationId - An EVE corporation ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_loyalty_stores_corporation_id_offers(parameters: {
        'corporationId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_loyalty_stores_corporation_id_offers_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_loyalty_stores_corporation_id_offers_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/loyalty/stores/{corporation_id}/offers/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{corporation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['corporationId'],
                    ''
                ).toString())}`
            );

            if (parameters['corporationId'] === undefined) {
                reject(new Error('Missing required  parameter: corporationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_markets_groupsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/groups/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of item groups

---
Alternate route: `/dev/markets/groups/`

Alternate route: `/legacy/markets/groups/`

Alternate route: `/v1/markets/groups/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_markets_groups

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_markets_groups(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_markets_groups_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/groups/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_markets_groups_market_group_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'marketGroupId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/groups/{market_group_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        path = path.replace(
            '{market_group_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['marketGroupId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on an item group

---
Alternate route: `/dev/markets/groups/{market_group_id}/`

Alternate route: `/legacy/markets/groups/{market_group_id}/`

Alternate route: `/v1/markets/groups/{market_group_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_markets_groups_market_group_id
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {integer} marketGroupId - An Eve item group ID
    */
    get_markets_groups_market_group_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'marketGroupId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_markets_groups_market_group_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_markets_groups_market_group_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/groups/{market_group_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            path = path.replace(
                '{market_group_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['marketGroupId'],
                    ''
                ).toString())}`
            );

            if (parameters['marketGroupId'] === undefined) {
                reject(new Error('Missing required  parameter: marketGroupId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_markets_pricesURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/prices/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of prices

---
Alternate route: `/dev/markets/prices/`

Alternate route: `/legacy/markets/prices/`

Alternate route: `/v1/markets/prices/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_markets_prices

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_markets_prices(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_markets_prices_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/prices/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_markets_structures_structure_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'structureId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/structures/{structure_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        path = path.replace(
            '{structure_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['structureId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return all orders in a structure

---
Alternate route: `/dev/markets/structures/{structure_id}/`

Alternate route: `/legacy/markets/structures/{structure_id}/`

Alternate route: `/v1/markets/structures/{structure_id}/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_markets_structures_structure_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {integer} structureId - Return orders in this structure
         * @param {string} token - Access token to use if unable to set a header
    */
    get_markets_structures_structure_id(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'structureId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_markets_structures_structure_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/structures/{structure_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            path = path.replace(
                '{structure_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['structureId'],
                    ''
                ).toString())}`
            );

            if (parameters['structureId'] === undefined) {
                reject(new Error('Missing required  parameter: structureId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_markets_region_id_historyURL(parameters: {
        'ifNoneMatch' ? : string,
        'regionId': number,
        'typeId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/{region_id}/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{region_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['regionId'],
                        ''
                    ).toString())}`
        );
        if (parameters['typeId'] !== undefined) {
            queryParameters['type_id'] = this.convertParameterCollectionFormat(
                parameters['typeId'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of historical market statistics for the specified type in a region

---
Alternate route: `/dev/markets/{region_id}/history/`

Alternate route: `/legacy/markets/{region_id}/history/`

Alternate route: `/v1/markets/{region_id}/history/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_markets_region_id_history

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} regionId - Return statistics in this region
         * @param {integer} typeId - Return statistics for this type
    */
    get_markets_region_id_history(parameters: {
        'ifNoneMatch' ? : string,
        'regionId': number,
        'typeId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_markets_region_id_history_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_markets_region_id_history_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_get_markets_region_id_history_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout > | ResponseWithBody < 520, Response_get_markets_region_id_history_520 >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/{region_id}/history/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{region_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['regionId'],
                    ''
                ).toString())}`
            );

            if (parameters['regionId'] === undefined) {
                reject(new Error('Missing required  parameter: regionId'));
                return;
            }

            if (parameters['typeId'] !== undefined) {
                queryParameters['type_id'] = this.convertParameterCollectionFormat(
                    parameters['typeId'],
                    ''
                );
            }

            if (parameters['typeId'] === undefined) {
                reject(new Error('Missing required  parameter: typeId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_markets_region_id_ordersURL(parameters: {
        'ifNoneMatch' ? : string,
        'orderType': "buy" | "sell" | "all",
        'page' ? : number,
        'regionId': number,
        'typeId' ? : number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/{region_id}/orders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['orderType'] !== undefined) {
            queryParameters['order_type'] = this.convertParameterCollectionFormat(
                parameters['orderType'],
                ''
            );
        }

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        path = path.replace(
            '{region_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['regionId'],
                        ''
                    ).toString())}`
        );
        if (parameters['typeId'] !== undefined) {
            queryParameters['type_id'] = this.convertParameterCollectionFormat(
                parameters['typeId'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of orders in a region

---
Alternate route: `/dev/markets/{region_id}/orders/`

Alternate route: `/legacy/markets/{region_id}/orders/`

Alternate route: `/v1/markets/{region_id}/orders/`

---
This route is cached for up to 300 seconds
    * @method
    * @name Esi#get_markets_region_id_orders

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} orderType - Filter buy/sell orders, return all orders by default. If you query without type_id, we always return both buy and sell orders
         * @param {integer} page - Which page of results to return
         * @param {integer} regionId - Return orders in this region
         * @param {integer} typeId - Return orders only for this type
    */
    get_markets_region_id_orders(parameters: {
        'ifNoneMatch' ? : string,
        'orderType': "buy" | "sell" | "all",
        'page' ? : number,
        'regionId': number,
        'typeId' ? : number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_markets_region_id_orders_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_markets_region_id_orders_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_get_markets_region_id_orders_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/{region_id}/orders/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['orderType'] !== undefined) {
                queryParameters['order_type'] = this.convertParameterCollectionFormat(
                    parameters['orderType'],
                    ''
                );
            }

            if (parameters['orderType'] === undefined) {
                reject(new Error('Missing required  parameter: orderType'));
                return;
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            path = path.replace(
                '{region_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['regionId'],
                    ''
                ).toString())}`
            );

            if (parameters['regionId'] === undefined) {
                reject(new Error('Missing required  parameter: regionId'));
                return;
            }

            if (parameters['typeId'] !== undefined) {
                queryParameters['type_id'] = this.convertParameterCollectionFormat(
                    parameters['typeId'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_markets_region_id_typesURL(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'regionId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/{region_id}/types/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        path = path.replace(
            '{region_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['regionId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of type IDs that have active orders in the region, for efficient market indexing.

---
Alternate route: `/dev/markets/{region_id}/types/`

Alternate route: `/legacy/markets/{region_id}/types/`

Alternate route: `/v1/markets/{region_id}/types/`

---
This route is cached for up to 600 seconds
    * @method
    * @name Esi#get_markets_region_id_types

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {integer} regionId - Return statistics in this region
    */
    get_markets_region_id_types(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'regionId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_markets_region_id_types_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/markets/{region_id}/types/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            path = path.replace(
                '{region_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['regionId'],
                    ''
                ).toString())}`
            );

            if (parameters['regionId'] === undefined) {
                reject(new Error('Missing required  parameter: regionId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_opportunities_groupsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/groups/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of opportunities groups

---
Alternate route: `/dev/opportunities/groups/`

Alternate route: `/legacy/opportunities/groups/`

Alternate route: `/v1/opportunities/groups/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_opportunities_groups

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_opportunities_groups(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_opportunities_groups_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/groups/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_opportunities_groups_group_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'groupId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/groups/{group_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{group_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['groupId'],
                        ''
                    ).toString())}`
        );

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return information of an opportunities group

---
Alternate route: `/dev/opportunities/groups/{group_id}/`

Alternate route: `/legacy/opportunities/groups/{group_id}/`

Alternate route: `/v1/opportunities/groups/{group_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_opportunities_groups_group_id
         * @param {string} acceptLanguage - Language to use in the response

         * @param {integer} groupId - ID of an opportunities group
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_opportunities_groups_group_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'groupId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_opportunities_groups_group_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/groups/{group_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{group_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['groupId'],
                    ''
                ).toString())}`
            );

            if (parameters['groupId'] === undefined) {
                reject(new Error('Missing required  parameter: groupId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_opportunities_tasksURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/tasks/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of opportunities tasks

---
Alternate route: `/dev/opportunities/tasks/`

Alternate route: `/legacy/opportunities/tasks/`

Alternate route: `/v1/opportunities/tasks/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_opportunities_tasks

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_opportunities_tasks(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_opportunities_tasks_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/tasks/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_opportunities_tasks_task_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'taskId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/tasks/{task_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{task_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['taskId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return information of an opportunities task

---
Alternate route: `/dev/opportunities/tasks/{task_id}/`

Alternate route: `/legacy/opportunities/tasks/{task_id}/`

Alternate route: `/v1/opportunities/tasks/{task_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_opportunities_tasks_task_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} taskId - ID of an opportunities task
    */
    get_opportunities_tasks_task_id(parameters: {
        'ifNoneMatch' ? : string,
        'taskId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_opportunities_tasks_task_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/opportunities/tasks/{task_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{task_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['taskId'],
                    ''
                ).toString())}`
            );

            if (parameters['taskId'] === undefined) {
                reject(new Error('Missing required  parameter: taskId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_route_origin_destinationURL(parameters: {
        'avoid' ? : Array < number >
            ,
        'connections' ? : Array < Array < number >
            >
            ,
        'destination': number,
        'flag' ? : "shortest" | "secure" | "insecure",
        'ifNoneMatch' ? : string,
        'origin': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/route/{origin}/{destination}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        if (parameters['avoid'] !== undefined) {
            queryParameters['avoid'] = this.convertParameterCollectionFormat(
                parameters['avoid'],
                ''
            );
        }

        if (parameters['connections'] !== undefined) {
            queryParameters['connections'] = this.convertParameterCollectionFormat(
                parameters['connections'],
                ''
            );
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{destination}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['destination'],
                        ''
                    ).toString())}`
        );
        if (parameters['flag'] !== undefined) {
            queryParameters['flag'] = this.convertParameterCollectionFormat(
                parameters['flag'],
                ''
            );
        }

        path = path.replace(
            '{origin}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['origin'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get the systems between origin and destination

---
Alternate route: `/dev/route/{origin}/{destination}/`

Alternate route: `/legacy/route/{origin}/{destination}/`

Alternate route: `/v1/route/{origin}/{destination}/`

---
This route is cached for up to 86400 seconds
    * @method
    * @name Esi#get_route_origin_destination
         * @param {array} avoid - avoid solar system ID(s)
         * @param {array} connections - connected solar system pairs

         * @param {integer} destination - destination solar system ID
         * @param {string} flag - route security preference
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} origin - origin solar system ID
    */
    get_route_origin_destination(parameters: {
        'avoid' ? : Array < number >
            ,
        'connections' ? : Array < Array < number >
            >
            ,
        'destination': number,
        'flag' ? : "shortest" | "secure" | "insecure",
        'ifNoneMatch' ? : string,
        'origin': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_route_origin_destination_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_route_origin_destination_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/route/{origin}/{destination}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['avoid'] !== undefined) {
                queryParameters['avoid'] = this.convertParameterCollectionFormat(
                    parameters['avoid'],
                    ''
                );
            }

            if (parameters['connections'] !== undefined) {
                queryParameters['connections'] = this.convertParameterCollectionFormat(
                    parameters['connections'],
                    ''
                );
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{destination}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['destination'],
                    ''
                ).toString())}`
            );

            if (parameters['destination'] === undefined) {
                reject(new Error('Missing required  parameter: destination'));
                return;
            }

            if (parameters['flag'] !== undefined) {
                queryParameters['flag'] = this.convertParameterCollectionFormat(
                    parameters['flag'],
                    ''
                );
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{origin}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['origin'],
                    ''
                ).toString())}`
            );

            if (parameters['origin'] === undefined) {
                reject(new Error('Missing required  parameter: origin'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_searchURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'categories': Array < "agent" | "alliance" | "character" | "constellation" | "corporation" | "faction" | "inventory_type" | "region" | "solar_system" | "station" >
            ,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'search': string,
        'strict' ? : boolean,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/search/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        if (parameters['categories'] !== undefined) {
            queryParameters['categories'] = this.convertParameterCollectionFormat(
                parameters['categories'],
                ''
            );
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters['search'] !== undefined) {
            queryParameters['search'] = this.convertParameterCollectionFormat(
                parameters['search'],
                ''
            );
        }

        if (parameters['strict'] !== undefined) {
            queryParameters['strict'] = this.convertParameterCollectionFormat(
                parameters['strict'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Search for entities that match a given sub-string.

---
Alternate route: `/dev/search/`

Alternate route: `/legacy/search/`

Alternate route: `/v2/search/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_search
         * @param {string} acceptLanguage - Language to use in the response
         * @param {array} categories - Type of entities to search for

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {string} search - The string to search on
         * @param {boolean} strict - Whether the search should be a strict match
    */
    get_search(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'categories': Array < "agent" | "alliance" | "character" | "constellation" | "corporation" | "faction" | "inventory_type" | "region" | "solar_system" | "station" >
            ,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'search': string,
        'strict' ? : boolean,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_search_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/search/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            if (parameters['categories'] !== undefined) {
                queryParameters['categories'] = this.convertParameterCollectionFormat(
                    parameters['categories'],
                    ''
                );
            }

            if (parameters['categories'] === undefined) {
                reject(new Error('Missing required  parameter: categories'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters['search'] !== undefined) {
                queryParameters['search'] = this.convertParameterCollectionFormat(
                    parameters['search'],
                    ''
                );
            }

            if (parameters['search'] === undefined) {
                reject(new Error('Missing required  parameter: search'));
                return;
            }

            if (parameters['strict'] !== undefined) {
                queryParameters['strict'] = this.convertParameterCollectionFormat(
                    parameters['strict'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_sovereignty_campaignsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/sovereignty/campaigns/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Shows sovereignty data for campaigns.

---
Alternate route: `/dev/sovereignty/campaigns/`

Alternate route: `/legacy/sovereignty/campaigns/`

Alternate route: `/v1/sovereignty/campaigns/`

---
This route is cached for up to 5 seconds
    * @method
    * @name Esi#get_sovereignty_campaigns

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_sovereignty_campaigns(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_sovereignty_campaigns_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/sovereignty/campaigns/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_sovereignty_mapURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/sovereignty/map/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Shows sovereignty information for solar systems

---
Alternate route: `/dev/sovereignty/map/`

Alternate route: `/legacy/sovereignty/map/`

Alternate route: `/v1/sovereignty/map/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_sovereignty_map

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_sovereignty_map(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_sovereignty_map_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/sovereignty/map/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_sovereignty_structuresURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/sovereignty/structures/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Shows sovereignty data for structures.

---
Alternate route: `/dev/sovereignty/structures/`

Alternate route: `/legacy/sovereignty/structures/`

Alternate route: `/v1/sovereignty/structures/`

---
This route is cached for up to 120 seconds
    * @method
    * @name Esi#get_sovereignty_structures

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_sovereignty_structures(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_sovereignty_structures_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/sovereignty/structures/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_statusURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/status/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * EVE Server status

---
Alternate route: `/dev/status/`

Alternate route: `/legacy/status/`

Alternate route: `/v1/status/`

---
This route is cached for up to 30 seconds
    * @method
    * @name Esi#get_status

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_status(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_status_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/status/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_ui_autopilot_waypointURL(parameters: {
        'addToBeginning': boolean,
        'clearOtherWaypoints': boolean,
        'destinationId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/autopilot/waypoint/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        if (parameters['addToBeginning'] !== undefined) {
            queryParameters['add_to_beginning'] = this.convertParameterCollectionFormat(
                parameters['addToBeginning'],
                ''
            );
        }

        if (parameters['clearOtherWaypoints'] !== undefined) {
            queryParameters['clear_other_waypoints'] = this.convertParameterCollectionFormat(
                parameters['clearOtherWaypoints'],
                ''
            );
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['destinationId'] !== undefined) {
            queryParameters['destination_id'] = this.convertParameterCollectionFormat(
                parameters['destinationId'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Set a solar system as autopilot waypoint

---
Alternate route: `/dev/ui/autopilot/waypoint/`

Alternate route: `/legacy/ui/autopilot/waypoint/`

Alternate route: `/v2/ui/autopilot/waypoint/`

    * @method
    * @name Esi#post_ui_autopilot_waypoint
         * @param {boolean} addToBeginning - Whether this solar system should be added to the beginning of all waypoints
         * @param {boolean} clearOtherWaypoints - Whether clean other waypoints beforing adding this one

         * @param {integer} destinationId - The destination to travel to, can be solar system, station or structure's id
         * @param {string} token - Access token to use if unable to set a header
    */
    post_ui_autopilot_waypoint(parameters: {
        'addToBeginning': boolean,
        'clearOtherWaypoints': boolean,
        'destinationId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/autopilot/waypoint/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['addToBeginning'] !== undefined) {
                queryParameters['add_to_beginning'] = this.convertParameterCollectionFormat(
                    parameters['addToBeginning'],
                    ''
                );
            }

            if (parameters['addToBeginning'] === undefined) {
                reject(new Error('Missing required  parameter: addToBeginning'));
                return;
            }

            if (parameters['clearOtherWaypoints'] !== undefined) {
                queryParameters['clear_other_waypoints'] = this.convertParameterCollectionFormat(
                    parameters['clearOtherWaypoints'],
                    ''
                );
            }

            if (parameters['clearOtherWaypoints'] === undefined) {
                reject(new Error('Missing required  parameter: clearOtherWaypoints'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['destinationId'] !== undefined) {
                queryParameters['destination_id'] = this.convertParameterCollectionFormat(
                    parameters['destinationId'],
                    ''
                );
            }

            if (parameters['destinationId'] === undefined) {
                reject(new Error('Missing required  parameter: destinationId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_ui_openwindow_contractURL(parameters: {
        'contractId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/contract/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        if (parameters['contractId'] !== undefined) {
            queryParameters['contract_id'] = this.convertParameterCollectionFormat(
                parameters['contractId'],
                ''
            );
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Open the contract window inside the client

---
Alternate route: `/dev/ui/openwindow/contract/`

Alternate route: `/legacy/ui/openwindow/contract/`

Alternate route: `/v1/ui/openwindow/contract/`

    * @method
    * @name Esi#post_ui_openwindow_contract
         * @param {integer} contractId - The contract to open

         * @param {string} token - Access token to use if unable to set a header
    */
    post_ui_openwindow_contract(parameters: {
        'contractId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/contract/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['contractId'] !== undefined) {
                queryParameters['contract_id'] = this.convertParameterCollectionFormat(
                    parameters['contractId'],
                    ''
                );
            }

            if (parameters['contractId'] === undefined) {
                reject(new Error('Missing required  parameter: contractId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_ui_openwindow_informationURL(parameters: {
        'targetId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/information/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['targetId'] !== undefined) {
            queryParameters['target_id'] = this.convertParameterCollectionFormat(
                parameters['targetId'],
                ''
            );
        }

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Open the information window for a character, corporation or alliance inside the client

---
Alternate route: `/dev/ui/openwindow/information/`

Alternate route: `/legacy/ui/openwindow/information/`

Alternate route: `/v1/ui/openwindow/information/`

    * @method
    * @name Esi#post_ui_openwindow_information

         * @param {integer} targetId - The target to open
         * @param {string} token - Access token to use if unable to set a header
    */
    post_ui_openwindow_information(parameters: {
        'targetId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/information/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['targetId'] !== undefined) {
                queryParameters['target_id'] = this.convertParameterCollectionFormat(
                    parameters['targetId'],
                    ''
                );
            }

            if (parameters['targetId'] === undefined) {
                reject(new Error('Missing required  parameter: targetId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_ui_openwindow_marketdetailsURL(parameters: {
        'token' ? : string,
        'typeId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/marketdetails/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters['typeId'] !== undefined) {
            queryParameters['type_id'] = this.convertParameterCollectionFormat(
                parameters['typeId'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Open the market details window for a specific typeID inside the client

---
Alternate route: `/dev/ui/openwindow/marketdetails/`

Alternate route: `/legacy/ui/openwindow/marketdetails/`

Alternate route: `/v1/ui/openwindow/marketdetails/`

    * @method
    * @name Esi#post_ui_openwindow_marketdetails

         * @param {string} token - Access token to use if unable to set a header
         * @param {integer} typeId - The item type to open in market window
    */
    post_ui_openwindow_marketdetails(parameters: {
        'token' ? : string,
        'typeId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/marketdetails/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters['typeId'] !== undefined) {
                queryParameters['type_id'] = this.convertParameterCollectionFormat(
                    parameters['typeId'],
                    ''
                );
            }

            if (parameters['typeId'] === undefined) {
                reject(new Error('Missing required  parameter: typeId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_ui_openwindow_newmailURL(parameters: {
        'newMail': {
            'body': string;
            'recipients': Array < number >
            ;
            'subject': string;
            'to_corp_or_alliance_id' ? : number;
            'to_mailing_list_id' ? : number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/newmail/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Open the New Mail window, according to settings from the request if applicable

---
Alternate route: `/dev/ui/openwindow/newmail/`

Alternate route: `/legacy/ui/openwindow/newmail/`

Alternate route: `/v1/ui/openwindow/newmail/`

    * @method
    * @name Esi#post_ui_openwindow_newmail

         * @param {} newMail - The details of mail to create
         * @param {string} token - Access token to use if unable to set a header
    */
    post_ui_openwindow_newmail(parameters: {
        'newMail': {
            'body': string;
            'recipients': Array < number >
            ;
            'subject': string;
            'to_corp_or_alliance_id' ? : number;
            'to_mailing_list_id' ? : number;
        } & {
            [key: string]: any;
        },
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 204, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_post_ui_openwindow_newmail_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/ui/openwindow/newmail/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['newMail'] !== undefined) {
                body = parameters['newMail'];
            }

            if (parameters['newMail'] === undefined) {
                reject(new Error('Missing required  parameter: newMail'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_ancestriesURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/ancestries/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get all character ancestries

---
Alternate route: `/dev/universe/ancestries/`

Alternate route: `/legacy/universe/ancestries/`

Alternate route: `/v1/universe/ancestries/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_ancestries
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_universe_ancestries(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_ancestries_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/ancestries/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_asteroid_belts_asteroid_belt_idURL(parameters: {
        'asteroidBeltId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/asteroid_belts/{asteroid_belt_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{asteroid_belt_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['asteroidBeltId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on an asteroid belt

---
Alternate route: `/dev/universe/asteroid_belts/{asteroid_belt_id}/`

Alternate route: `/legacy/universe/asteroid_belts/{asteroid_belt_id}/`

Alternate route: `/v1/universe/asteroid_belts/{asteroid_belt_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_asteroid_belts_asteroid_belt_id
         * @param {integer} asteroidBeltId - asteroid_belt_id integer

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_asteroid_belts_asteroid_belt_id(parameters: {
        'asteroidBeltId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_asteroid_belts_asteroid_belt_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_asteroid_belts_asteroid_belt_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/asteroid_belts/{asteroid_belt_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            path = path.replace(
                '{asteroid_belt_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['asteroidBeltId'],
                    ''
                ).toString())}`
            );

            if (parameters['asteroidBeltId'] === undefined) {
                reject(new Error('Missing required  parameter: asteroidBeltId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_bloodlinesURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/bloodlines/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of bloodlines

---
Alternate route: `/dev/universe/bloodlines/`

Alternate route: `/legacy/universe/bloodlines/`

Alternate route: `/v1/universe/bloodlines/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_bloodlines
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_universe_bloodlines(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_bloodlines_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/bloodlines/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_categoriesURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/categories/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of item categories

---
Alternate route: `/dev/universe/categories/`

Alternate route: `/legacy/universe/categories/`

Alternate route: `/v1/universe/categories/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_categories

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_categories(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_categories_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/categories/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_categories_category_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'categoryId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/categories/{category_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{category_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['categoryId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information of an item category

---
Alternate route: `/dev/universe/categories/{category_id}/`

Alternate route: `/legacy/universe/categories/{category_id}/`

Alternate route: `/v1/universe/categories/{category_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_categories_category_id
         * @param {string} acceptLanguage - Language to use in the response
         * @param {integer} categoryId - An Eve item category ID

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_universe_categories_category_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'categoryId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_categories_category_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_categories_category_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/categories/{category_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            path = path.replace(
                '{category_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['categoryId'],
                    ''
                ).toString())}`
            );

            if (parameters['categoryId'] === undefined) {
                reject(new Error('Missing required  parameter: categoryId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_constellationsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/constellations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of constellations

---
Alternate route: `/dev/universe/constellations/`

Alternate route: `/legacy/universe/constellations/`

Alternate route: `/v1/universe/constellations/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_constellations

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_constellations(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_constellations_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/constellations/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_constellations_constellation_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'constellationId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/constellations/{constellation_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        path = path.replace(
            '{constellation_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['constellationId'],
                        ''
                    ).toString())}`
        );
        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a constellation

---
Alternate route: `/dev/universe/constellations/{constellation_id}/`

Alternate route: `/legacy/universe/constellations/{constellation_id}/`

Alternate route: `/v1/universe/constellations/{constellation_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_constellations_constellation_id
         * @param {string} acceptLanguage - Language to use in the response
         * @param {integer} constellationId - constellation_id integer

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_universe_constellations_constellation_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'constellationId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_constellations_constellation_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_constellations_constellation_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/constellations/{constellation_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            path = path.replace(
                '{constellation_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['constellationId'],
                    ''
                ).toString())}`
            );

            if (parameters['constellationId'] === undefined) {
                reject(new Error('Missing required  parameter: constellationId'));
                return;
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_factionsURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/factions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of factions

---
Alternate route: `/dev/universe/factions/`

Alternate route: `/v2/universe/factions/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_factions
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_universe_factions(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_factions_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/factions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_graphicsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/graphics/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of graphics

---
Alternate route: `/dev/universe/graphics/`

Alternate route: `/legacy/universe/graphics/`

Alternate route: `/v1/universe/graphics/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_graphics

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_graphics(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_graphics_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/graphics/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_graphics_graphic_idURL(parameters: {
        'graphicId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/graphics/{graphic_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{graphic_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['graphicId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a graphic

---
Alternate route: `/dev/universe/graphics/{graphic_id}/`

Alternate route: `/legacy/universe/graphics/{graphic_id}/`

Alternate route: `/v1/universe/graphics/{graphic_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_graphics_graphic_id

         * @param {integer} graphicId - graphic_id integer
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_graphics_graphic_id(parameters: {
        'graphicId': number,
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_graphics_graphic_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_graphics_graphic_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/graphics/{graphic_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{graphic_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['graphicId'],
                    ''
                ).toString())}`
            );

            if (parameters['graphicId'] === undefined) {
                reject(new Error('Missing required  parameter: graphicId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_groupsURL(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/groups/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of item groups

---
Alternate route: `/dev/universe/groups/`

Alternate route: `/legacy/universe/groups/`

Alternate route: `/v1/universe/groups/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_groups

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
    */
    get_universe_groups(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_groups_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/groups/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_groups_group_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'groupId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/groups/{group_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{group_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['groupId'],
                        ''
                    ).toString())}`
        );

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on an item group

---
Alternate route: `/dev/universe/groups/{group_id}/`

Alternate route: `/legacy/universe/groups/{group_id}/`

Alternate route: `/v1/universe/groups/{group_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_groups_group_id
         * @param {string} acceptLanguage - Language to use in the response

         * @param {integer} groupId - An Eve item group ID
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_universe_groups_group_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'groupId': number,
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_groups_group_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_groups_group_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/groups/{group_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            path = path.replace(
                '{group_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['groupId'],
                    ''
                ).toString())}`
            );

            if (parameters['groupId'] === undefined) {
                reject(new Error('Missing required  parameter: groupId'));
                return;
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_universe_idsURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'names': Array < string >
            ,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/ids/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Resolve a set of names to IDs in the following categories: agents, alliances, characters, constellations, corporations factions, inventory_types, regions, stations, and systems. Only exact matches will be returned. All names searched for are cached for 12 hours

---
Alternate route: `/dev/universe/ids/`

Alternate route: `/legacy/universe/ids/`

Alternate route: `/v1/universe/ids/`

    * @method
    * @name Esi#post_universe_ids
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {} names - The names to resolve
    */
    post_universe_ids(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'names': Array < string >
            ,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_post_universe_ids_200 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/ids/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters['names'] !== undefined) {
                body = parameters['names'];
            }

            if (parameters['names'] === undefined) {
                reject(new Error('Missing required  parameter: names'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_moons_moon_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'moonId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/moons/{moon_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{moon_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['moonId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a moon

---
Alternate route: `/dev/universe/moons/{moon_id}/`

Alternate route: `/legacy/universe/moons/{moon_id}/`

Alternate route: `/v1/universe/moons/{moon_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_moons_moon_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} moonId - moon_id integer
    */
    get_universe_moons_moon_id(parameters: {
        'ifNoneMatch' ? : string,
        'moonId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_moons_moon_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_moons_moon_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/moons/{moon_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{moon_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['moonId'],
                    ''
                ).toString())}`
            );

            if (parameters['moonId'] === undefined) {
                reject(new Error('Missing required  parameter: moonId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    post_universe_namesURL(parameters: {
        'ids': Array < number >
            ,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/names/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        queryParameters = {};

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Resolve a set of IDs to names and categories. Supported ID's for resolving are: Characters, Corporations, Alliances, Stations, Solar Systems, Constellations, Regions, Types, Factions

---
Alternate route: `/dev/universe/names/`

Alternate route: `/v3/universe/names/`

    * @method
    * @name Esi#post_universe_names

         * @param {} ids - The ids to resolve
    */
    post_universe_names(parameters: {
        'ids': Array < number >
            ,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_post_universe_names_200 > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_post_universe_names_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/names/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ids'] !== undefined) {
                body = parameters['ids'];
            }

            if (parameters['ids'] === undefined) {
                reject(new Error('Missing required  parameter: ids'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            form = queryParameters;
            queryParameters = {};

            this.request('POST', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_planets_planet_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'planetId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/planets/{planet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{planet_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['planetId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a planet

---
Alternate route: `/dev/universe/planets/{planet_id}/`

Alternate route: `/legacy/universe/planets/{planet_id}/`

Alternate route: `/v1/universe/planets/{planet_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_planets_planet_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} planetId - planet_id integer
    */
    get_universe_planets_planet_id(parameters: {
        'ifNoneMatch' ? : string,
        'planetId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_planets_planet_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_planets_planet_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/planets/{planet_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{planet_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['planetId'],
                    ''
                ).toString())}`
            );

            if (parameters['planetId'] === undefined) {
                reject(new Error('Missing required  parameter: planetId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_racesURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/races/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of character races

---
Alternate route: `/dev/universe/races/`

Alternate route: `/legacy/universe/races/`

Alternate route: `/v1/universe/races/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_races
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
    */
    get_universe_races(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_races_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/races/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_regionsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/regions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of regions

---
Alternate route: `/dev/universe/regions/`

Alternate route: `/legacy/universe/regions/`

Alternate route: `/v1/universe/regions/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_regions

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_regions(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_regions_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/regions/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_regions_region_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'regionId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/regions/{region_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        path = path.replace(
            '{region_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['regionId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a region

---
Alternate route: `/dev/universe/regions/{region_id}/`

Alternate route: `/legacy/universe/regions/{region_id}/`

Alternate route: `/v1/universe/regions/{region_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_regions_region_id
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {integer} regionId - region_id integer
    */
    get_universe_regions_region_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'regionId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_regions_region_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_regions_region_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/regions/{region_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            path = path.replace(
                '{region_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['regionId'],
                    ''
                ).toString())}`
            );

            if (parameters['regionId'] === undefined) {
                reject(new Error('Missing required  parameter: regionId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_schematics_schematic_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'schematicId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/schematics/{schematic_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{schematic_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['schematicId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a planetary factory schematic

---
Alternate route: `/dev/universe/schematics/{schematic_id}/`

Alternate route: `/legacy/universe/schematics/{schematic_id}/`

Alternate route: `/v1/universe/schematics/{schematic_id}/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_universe_schematics_schematic_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} schematicId - A PI schematic ID
    */
    get_universe_schematics_schematic_id(parameters: {
        'ifNoneMatch' ? : string,
        'schematicId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_schematics_schematic_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_schematics_schematic_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/schematics/{schematic_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{schematic_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['schematicId'],
                    ''
                ).toString())}`
            );

            if (parameters['schematicId'] === undefined) {
                reject(new Error('Missing required  parameter: schematicId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_stargates_stargate_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'stargateId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/stargates/{stargate_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{stargate_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['stargateId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a stargate

---
Alternate route: `/dev/universe/stargates/{stargate_id}/`

Alternate route: `/legacy/universe/stargates/{stargate_id}/`

Alternate route: `/v1/universe/stargates/{stargate_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_stargates_stargate_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} stargateId - stargate_id integer
    */
    get_universe_stargates_stargate_id(parameters: {
        'ifNoneMatch' ? : string,
        'stargateId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_stargates_stargate_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_stargates_stargate_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/stargates/{stargate_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{stargate_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['stargateId'],
                    ''
                ).toString())}`
            );

            if (parameters['stargateId'] === undefined) {
                reject(new Error('Missing required  parameter: stargateId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_stars_star_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'starId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/stars/{star_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{star_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['starId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a star

---
Alternate route: `/dev/universe/stars/{star_id}/`

Alternate route: `/legacy/universe/stars/{star_id}/`

Alternate route: `/v1/universe/stars/{star_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_stars_star_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} starId - star_id integer
    */
    get_universe_stars_star_id(parameters: {
        'ifNoneMatch' ? : string,
        'starId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_stars_star_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/stars/{star_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{star_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['starId'],
                    ''
                ).toString())}`
            );

            if (parameters['starId'] === undefined) {
                reject(new Error('Missing required  parameter: starId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_stations_station_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'stationId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/stations/{station_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{station_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['stationId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a station

---
Alternate route: `/dev/universe/stations/{station_id}/`

Alternate route: `/v2/universe/stations/{station_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_stations_station_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} stationId - station_id integer
    */
    get_universe_stations_station_id(parameters: {
        'ifNoneMatch' ? : string,
        'stationId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_stations_station_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_stations_station_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/stations/{station_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{station_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['stationId'],
                    ''
                ).toString())}`
            );

            if (parameters['stationId'] === undefined) {
                reject(new Error('Missing required  parameter: stationId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_structuresURL(parameters: {
        'filter' ? : "market" | "manufacturing_basic",
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/structures/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['filter'] !== undefined) {
            queryParameters['filter'] = this.convertParameterCollectionFormat(
                parameters['filter'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * List all public structures

---
Alternate route: `/dev/universe/structures/`

Alternate route: `/legacy/universe/structures/`

Alternate route: `/v1/universe/structures/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_universe_structures

         * @param {string} filter - Only list public structures that have this service online
         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_structures(parameters: {
        'filter' ? : "market" | "manufacturing_basic",
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_structures_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/structures/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['filter'] !== undefined) {
                queryParameters['filter'] = this.convertParameterCollectionFormat(
                    parameters['filter'],
                    ''
                );
            }

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_structures_structure_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'structureId': number,
        'token' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/structures/{structure_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{structure_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['structureId'],
                        ''
                    ).toString())}`
        );
        if (parameters['token'] !== undefined) {
            queryParameters['token'] = this.convertParameterCollectionFormat(
                parameters['token'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Returns information on requested structure if you are on the ACL. Otherwise, returns "Forbidden" for all inputs.

---
Alternate route: `/dev/universe/structures/{structure_id}/`

Alternate route: `/v2/universe/structures/{structure_id}/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_universe_structures_structure_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} structureId - An Eve structure ID
         * @param {string} token - Access token to use if unable to set a header
    */
    get_universe_structures_structure_id(parameters: {
        'ifNoneMatch' ? : string,
        'structureId': number,
        'token' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_structures_structure_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 401, unauthorized > | ResponseWithBody < 403, forbidden > | ResponseWithBody < 404, Response_get_universe_structures_structure_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/structures/{structure_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{structure_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['structureId'],
                    ''
                ).toString())}`
            );

            if (parameters['structureId'] === undefined) {
                reject(new Error('Missing required  parameter: structureId'));
                return;
            }

            if (parameters['token'] !== undefined) {
                queryParameters['token'] = this.convertParameterCollectionFormat(
                    parameters['token'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_system_jumpsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/system_jumps/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get the number of jumps in solar systems within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with jumps will be listed

---
Alternate route: `/dev/universe/system_jumps/`

Alternate route: `/legacy/universe/system_jumps/`

Alternate route: `/v1/universe/system_jumps/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_universe_system_jumps

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_system_jumps(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_system_jumps_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/system_jumps/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_system_killsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/system_kills/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get the number of ship, pod and NPC kills per solar system within the last hour ending at the timestamp of the Last-Modified header, excluding wormhole space. Only systems with kills will be listed

---
Alternate route: `/dev/universe/system_kills/`

Alternate route: `/v2/universe/system_kills/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_universe_system_kills

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_system_kills(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_system_kills_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/system_kills/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_systemsURL(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/systems/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of solar systems

---
Alternate route: `/dev/universe/systems/`

Alternate route: `/legacy/universe/systems/`

Alternate route: `/v1/universe/systems/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_systems

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
    */
    get_universe_systems(parameters: {
        'ifNoneMatch' ? : string,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_systems_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/systems/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_systems_system_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'systemId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/systems/{system_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        path = path.replace(
            '{system_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['systemId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a solar system.

---
Alternate route: `/dev/universe/systems/{system_id}/`

Alternate route: `/v4/universe/systems/{system_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_systems_system_id
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {integer} systemId - system_id integer
    */
    get_universe_systems_system_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'systemId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_systems_system_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_systems_system_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/systems/{system_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            path = path.replace(
                '{system_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['systemId'],
                    ''
                ).toString())}`
            );

            if (parameters['systemId'] === undefined) {
                reject(new Error('Missing required  parameter: systemId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_typesURL(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/types/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get a list of type ids

---
Alternate route: `/dev/universe/types/`

Alternate route: `/legacy/universe/types/`

Alternate route: `/v1/universe/types/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_types

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
    */
    get_universe_types(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_types_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/types/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_universe_types_type_idURL(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'typeId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/types/{type_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['language'] !== undefined) {
            queryParameters['language'] = this.convertParameterCollectionFormat(
                parameters['language'],
                ''
            );
        }

        path = path.replace(
            '{type_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['typeId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Get information on a type

---
Alternate route: `/dev/universe/types/{type_id}/`

Alternate route: `/v3/universe/types/{type_id}/`

---
This route expires daily at 11:05
    * @method
    * @name Esi#get_universe_types_type_id
         * @param {string} acceptLanguage - Language to use in the response

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {string} language - Language to use in the response, takes precedence over Accept-Language
         * @param {integer} typeId - An Eve item type ID
    */
    get_universe_types_type_id(parameters: {
        'acceptLanguage' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'ifNoneMatch' ? : string,
        'language' ? : "de" | "en-us" | "fr" | "ja" | "ru" | "zh" | "ko",
        'typeId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_universe_types_type_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 404, Response_get_universe_types_type_id_404 > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/universe/types/{type_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            if (parameters['acceptLanguage'] !== undefined) {
                headers['Accept-Language'] = parameters['acceptLanguage'];
            }

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['language'] !== undefined) {
                queryParameters['language'] = this.convertParameterCollectionFormat(
                    parameters['language'],
                    ''
                );
            }

            path = path.replace(
                '{type_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['typeId'],
                    ''
                ).toString())}`
            );

            if (parameters['typeId'] === undefined) {
                reject(new Error('Missing required  parameter: typeId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_warsURL(parameters: {
        'ifNoneMatch' ? : string,
        'maxWarId' ? : number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/wars/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['maxWarId'] !== undefined) {
            queryParameters['max_war_id'] = this.convertParameterCollectionFormat(
                parameters['maxWarId'],
                ''
            );
        }

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of wars

---
Alternate route: `/dev/wars/`

Alternate route: `/legacy/wars/`

Alternate route: `/v1/wars/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_wars

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} maxWarId - Only return wars with ID smaller than this
    */
    get_wars(parameters: {
        'ifNoneMatch' ? : string,
        'maxWarId' ? : number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_wars_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/wars/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['maxWarId'] !== undefined) {
                queryParameters['max_war_id'] = this.convertParameterCollectionFormat(
                    parameters['maxWarId'],
                    ''
                );
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_wars_war_idURL(parameters: {
        'ifNoneMatch' ? : string,
        'warId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/wars/{war_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        path = path.replace(
            '{war_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['warId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return details about a war

---
Alternate route: `/dev/wars/{war_id}/`

Alternate route: `/legacy/wars/{war_id}/`

Alternate route: `/v1/wars/{war_id}/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_wars_war_id

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} warId - ID for a war
    */
    get_wars_war_id(parameters: {
        'ifNoneMatch' ? : string,
        'warId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_wars_war_id_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_get_wars_war_id_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/wars/{war_id}/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            path = path.replace(
                '{war_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['warId'],
                    ''
                ).toString())}`
            );

            if (parameters['warId'] === undefined) {
                reject(new Error('Missing required  parameter: warId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

    get_wars_war_id_killmailsURL(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'warId': number,
    } & CommonRequestOptions): string {
        let queryParameters: QueryParameters = {};
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/wars/{war_id}/killmails/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        queryParameters['datasource'] = 'tranquility';

        if (parameters['page'] !== undefined) {
            queryParameters['page'] = this.convertParameterCollectionFormat(
                parameters['page'],
                ''
            );
        }

        path = path.replace(
            '{war_id}',
            `${encodeURIComponent(this.convertParameterCollectionFormat(
                        parameters['warId'],
                        ''
                    ).toString())}`
        );

        if (parameters.$queryParameters) {
            queryParameters = {
                ...queryParameters,
                ...parameters.$queryParameters
            };
        }

        let keys = Object.keys(queryParameters);
        return domain + path + (keys.length > 0 ? '?' + (keys.map(key => key + '=' + encodeURIComponent(queryParameters[key])).join('&')) : '');
    }

    /**
    * Return a list of kills related to a war

---
Alternate route: `/dev/wars/{war_id}/killmails/`

Alternate route: `/legacy/wars/{war_id}/killmails/`

Alternate route: `/v1/wars/{war_id}/killmails/`

---
This route is cached for up to 3600 seconds
    * @method
    * @name Esi#get_wars_war_id_killmails

         * @param {string} ifNoneMatch - ETag from a previous request. A 304 will be returned if this matches the current ETag
         * @param {integer} page - Which page of results to return
         * @param {integer} warId - A valid war ID
    */
    get_wars_war_id_killmails(parameters: {
        'ifNoneMatch' ? : string,
        'page' ? : number,
        'warId': number,
    } & CommonRequestOptions): Promise < ResponseWithBody < 200, Response_get_wars_war_id_killmails_200 > | ResponseWithBody < 304, void > | ResponseWithBody < 400, bad_request > | ResponseWithBody < 420, error_limited > | ResponseWithBody < 422, Response_get_wars_war_id_killmails_422 > | ResponseWithBody < 500, internal_server_error > | ResponseWithBody < 503, service_unavailable > | ResponseWithBody < 504, gateway_timeout >> {
        const domain = parameters.$domain ? parameters.$domain : this.domain;
        let path = '/wars/{war_id}/killmails/';
        if (parameters.$path) {
            path = (typeof(parameters.$path) === 'function') ? parameters.$path(path) : parameters.$path;
        }

        let body: any;
        let queryParameters: QueryParameters = {};
        let headers: RequestHeaders = {};
        let form: any = {};
        return new Promise((resolve, reject) => {
            headers['Accept'] = 'application/json';
            headers['Content-Type'] = 'application/json';

            queryParameters['datasource'] = 'tranquility';

            if (parameters['ifNoneMatch'] !== undefined) {
                headers['If-None-Match'] = parameters['ifNoneMatch'];
            }

            if (parameters['page'] !== undefined) {
                queryParameters['page'] = this.convertParameterCollectionFormat(
                    parameters['page'],
                    ''
                );
            }

            path = path.replace(
                '{war_id}',
                `${encodeURIComponent(this.convertParameterCollectionFormat(
                    parameters['warId'],
                    ''
                ).toString())}`
            );

            if (parameters['warId'] === undefined) {
                reject(new Error('Missing required  parameter: warId'));
                return;
            }

            if (parameters.$queryParameters) {
                queryParameters = {
                    ...queryParameters,
                    ...parameters.$queryParameters
                };
            }

            this.request('GET', domain + path, body, headers, queryParameters, form, reject, resolve, parameters);
        });
    }

}

export default Esi;